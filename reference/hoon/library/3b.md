##chapter 3b, standard library

##section 3bA, lite number theory

###++fu

```
++  fu                                                  ::  modulo (mul p q)
  |=  a=[p=@ q=@]
  =+  b=?:(=([0 0] a) 0 (~(inv fo p.a) (~(sit fo p.a) q.a)))
  |%
```

XX document

###++dif

```
  ++  dif
    |=  [c=[@ @] d=[@ @]]
    [(~(dif fo p.a) -.c -.d) (~(dif fo q.a) +.c +.d)]
  ::
```

XX document

###++exp

```
  ++  exp
    |=  [c=@ d=[@ @]]
    :-  (~(exp fo p.a) (mod c (dec p.a)) -.d)
    (~(exp fo q.a) (mod c (dec q.a)) +.d)
  ::
```

XX document

###++out

```
  ++  out                                               ::  garner's formula
    |=  c=[@ @]
    %+  add
      +.c
    (mul q.a (~(pro fo p.a) b (~(dif fo p.a) -.c (~(sit fo p.a) +.c))))
  ::
```

XX document

###++pro

```
  ++  pro
    |=  [c=[@ @] d=[@ @]]
    [(~(pro fo p.a) -.c -.d) (~(pro fo q.a) +.c +.d)]
  ::
```

XX document

###++sum

```
  ++  sum
    |=  [c=[@ @] d=[@ @]]
    [(~(sum fo p.a) -.c -.d) (~(sum fo q.a) +.c +.d)]
  ::
```

XX document

###++sit

```
  ++  sit
    |=  c=@
    [(mod c p.a) (mod c q.a)]
```

XX document

##section 3bB, cryptosuites

###++crua

```
++  crua  !:                                            ::  cryptosuite A (RSA)
  ^-  acru
  =|  [mos=@ pon=(unit ,[p=@ q=@ r=[p=@ q=@] s=_*fu])]
  =>  |%
```

XX document

###++mx

```
      ++  mx  (dec (met 0 mos))                         ::  bit length
```

XX document

###++dap

```
      ++  dap                                           ::  OEAP decode
        |=  [wid=@ xar=@ dog=@]  ^-  [p=@ q=@]
        =+  pav=(sub wid xar)
        =+  qoy=(cut 0 [xar pav] dog)
        =+  dez=(mix (end 0 xar dog) (shaw %pad-b xar qoy))
        [dez (mix qoy (shaw %pad-a pav dez))]
      ::
```

XX document

###++pad

```
      ++  pad                                           ::  OEAP encode
        |=  [wid=@ rax=[p=@ q=@] meg=@]  ^-  @
        =+  pav=(sub wid p.rax)
        ?>  (gte pav (met 0 meg))
        ^-  @
        =+  qoy=(mix meg (shaw %pad-a pav q.rax))
        =+  dez=(mix q.rax (shaw %pad-b p.rax qoy))
        (can 0 [p.rax dez] [pav qoy] ~)
  |%
```

XX document

###++pull

```
      ++  pull  |=(a=@ (~(exp fo mos) 3 a))
```

XX document

###++push

```
      ++  push  |=(a=@ (~(exp fo mos) 5 a))
```

XX document

###++pump

```
      ++  pump
        |=  a=@  ^-  @
        ?~  pon  !!
        (out.s.u.pon (exp.s.u.pon p.r.u.pon (sit.s.u.pon a)))
      ::
```

XX document

###++punt

```
      ++  punt
        |=  a=@  ^-  @
        ?~  pon  !!
        (out.s.u.pon (exp.s.u.pon q.r.u.pon (sit.s.u.pon a)))
  |%
```

XX document

###++as

```
  ++  as
    =>  |%
```

XX document

###++haul

```
        ++  haul                                        ::  revealing haul
          |=  a=pass
          !!
    ^?
    |%  ++  seal
          |=  [a=pass b=@ c=@]
          ^-  @
          !!
```

XX document

###++seal

``````

XX document

###++sign

```
        ++  sign
          |=  [a=@ b=@]  ^-  @
          !!
```

XX document

###++sure

```
        ++  sure
          |=  [a=@ b=@]
          ^-  (unit ,@)
          !!
```

XX document

###++tear

```
        ++  tear
          |=  [a=pass b=@]
          ^-  (unit ,[p=@ q=@])
          !!
  ::
```

XX document

###++de

```
  ++  de
    |+  [key=@ cep=@]  ^-  (unit ,@)
    !!
  ::
```

XX document

###++dy

```
  ++  dy
    |+  [a=@ b=@]  ^-  @
    !!
```

XX document

###++en

```
  ++  en
    |+  [key=@ msg=@]  ^-  @ux
    !!
  ::
```

XX document

###++ex

```
  ++  ex  ^?
    |%  ++  fig  ^-  @uvH  (shaf %bfig puc)
```

XX document

###++fig

``````

XX document

###++pac

```
        ++  pac  ^-  @uvG  (end 6 1 (shaf %acod sec))
```

XX document

###++pub

```
        ++  pub  ^-  pass  (cat 3 'b' puc)
```

XX document

###++sec

```
        ++  sec  ^-  ring  sed
  ::
```

XX document

###++nu

```
  ++  nu
    ^?
    |%  ++  com
          |=  a=@
          ^+  ^?(..nu)
          ..nu(sed ~, puc a)
        ::
```

XX document

###++elcm

```
        ++  elcm
          |=  [a=@ b=@]
          (div (mul a b) d:(egcd a b))
        ::
```

XX document

###++eldm

```
        ++  eldm
          |=  [a=@ b=@ c=@]
          (~(inv fo (elcm (dec b) (dec c))) a)
        ::
```

XX document

###++ersa

```
        ++  ersa
          |=  [a=@ b=@]
          [a b [(eldm 3 a b) (eldm 5 a b)] (fu a b)]
    ^?
    |%  ++  com
          |=  a=@
          ^+  ^?(..nu)
          ..nu(mos a, pon ~)
        ::
```

XX document

###++com

``````

XX document

###++pit

```
        ++  pit
          |=  [a=@ b=@]
          ^+  ^?(..nu)
          ..nu(sed b, puc (puck:ed b))
        ::
```

XX document

###++nol

```
        ++  nol
          |=  a=@
          ^+  ^?(..nu)
          ..nu(sed a, puc (puck:ed a))
```

XX document

###++bruw

```
++  bruw                                                ::  create keypair
  |=  [a=@ b=@]                                         ::  width seed
  ^-  acru
  (pit:nu:crua a b)
::
```

XX document

###++haul

```
        ++  haul                                        ::  revealing haul
          |=  a=pass
          !!
    ^?
    |%  ++  seal
          |=  [a=pass b=@ c=@]
          ^-  @
          !!
```

XX document

###++weur

```
++  weur                                                ::  activate secret key
  |=  a=ring
  ^-  acru
  =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]
  ?>  =('A' mag)
  (nol:nu:crua bod)
::
```

XX document

###++trua

```
++  trua                                                ::  test rsa
  |=  msg=@tas
  ^-  @
  =+  ali=(bruw 1.024 (shax 'ali'))
  =+  bob=(bruw 1.024 (shax 'bob'))
  =+  tef=(sign:as.ali [0 msg])
  =+  lov=(sure:as.ali [0 tef])
  ?.  &(?=(^ lov) =(msg u.lov))
    ~|(%test-fail-sign !!)
  =+  key=(shax (shax (shax msg)))
  =+  sax=(seal:as.ali pub:ex.bob key msg)
  =+  tin=(tear:as.bob pub:ex.ali sax)
  ?.  &(?=(^ tin) =(key p.u.tin) =(msg q.u.tin))
    ~|(%test-fail-seal !!)
  msg
::
```

XX document

###++crub

```
++  crub                                                ::  cryptosuite B (Ed)
  ^-  acru
  =|  [puc=pass sed=ring]
  =>  |%
```

XX document

###++dap

```
      ++  dap                                           ::  OEAP decode
        |=  [wid=@ xar=@ dog=@]  ^-  [p=@ q=@]
        =+  pav=(sub wid xar)
        =+  qoy=(cut 0 [xar pav] dog)
        =+  dez=(mix (end 0 xar dog) (shaw %pad-b xar qoy))
        [dez (mix qoy (shaw %pad-a pav dez))]
      ::
```

XX document

###++pad

```
      ++  pad                                           ::  OEAP encode
        |=  [wid=@ rax=[p=@ q=@] meg=@]  ^-  @
        =+  pav=(sub wid p.rax)
        ?>  (gte pav (met 0 meg))
        ^-  @
        =+  qoy=(mix meg (shaw %pad-a pav q.rax))
        =+  dez=(mix q.rax (shaw %pad-b p.rax qoy))
        (can 0 [p.rax dez] [pav qoy] ~)
  |%
```

XX document

###++as

```
  ++  as
    =>  |%
```

XX document

###++haul

```
        ++  haul                                        ::  revealing haul
          |=  a=pass
          !!
    ^?
    |%  ++  seal
          |=  [a=pass b=@ c=@]
          ^-  @
          !!
```

XX document

###++seal

``````

XX document

###++sign

```
        ++  sign
          |=  [a=@ b=@]  ^-  @
          !!
```

XX document

###++sure

```
        ++  sure
          |=  [a=@ b=@]
          ^-  (unit ,@)
          !!
```

XX document

###++tear

```
        ++  tear
          |=  [a=pass b=@]
          ^-  (unit ,[p=@ q=@])
          !!
  ::
```

XX document

###++de

```
  ++  de
    |+  [key=@ cep=@]  ^-  (unit ,@)
    !!
  ::
```

XX document

###++dy

```
  ++  dy
    |+  [a=@ b=@]  ^-  @
    !!
```

XX document

###++en

```
  ++  en
    |+  [key=@ msg=@]  ^-  @ux
    !!
  ::
```

XX document

###++ex

```
  ++  ex  ^?
    |%  ++  fig  ^-  @uvH  (shaf %bfig puc)
```

XX document

###++fig

``````

XX document

###++pac

```
        ++  pac  ^-  @uvG  (end 6 1 (shaf %acod sec))
```

XX document

###++pub

```
        ++  pub  ^-  pass  (cat 3 'b' puc)
```

XX document

###++sec

```
        ++  sec  ^-  ring  sed
  ::
```

XX document

###++nu

```
  ++  nu
    ^?
    |%  ++  com
          |=  a=@
          ^+  ^?(..nu)
          ..nu(sed ~, puc a)
        ::
```

XX document

###++com

``````

XX document

###++pit

```
        ++  pit
          |=  [a=@ b=@]
          ^+  ^?(..nu)
          ..nu(sed b, puc (puck:ed b))
        ::
```

XX document

###++nol

```
        ++  nol
          |=  a=@
          ^+  ^?(..nu)
          ..nu(sed a, puc (puck:ed a))
```

XX document

###++brew

```
++  brew                                                ::  create keypair
  |=  [a=@ b=@]                                         ::  width seed
  ^-  acru
  (pit:nu:crub a b)
::
```

XX document

###++hail

```
++  hail                                                ::  activate public key
  |=  a=pass
  ^-  acru
  =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]
  ?>  =('b' mag)
  (com:nu:crub bod)
::
```

XX document

###++wear

```
++  wear                                                ::  activate secret key
  |=  a=ring
  ^-  acru
  =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]
  ?>  =('b' mag)
  (nol:nu:crub bod)
::
```

XX document

###++trub

```
++  trub                                                ::  test ed
  |=  msg=@tas
  ^-  @
  =+  ali=(brew 1.024 (shax 'ali'))
  =+  bob=(brew 1.024 (shax 'bob'))
  =+  tef=(sign:as.ali [0 msg])
  =+  lov=(sure:as.ali [0 tef])
  ?.  &(?=(^ lov) =(msg u.lov))
    ~|(%test-fail-sign !!)
  =+  key=(shax (shax (shax msg)))
  =+  sax=(seal:as.ali pub:ex.bob key msg)
  =+  tin=(tear:as.bob pub:ex.ali sax)
  ?.  &(?=(^ tin) =(key p.u.tin) =(msg q.u.tin))
    ~|(%test-fail-seal !!)
  msg
::
```

XX document

###++hmac

```
++  hmac                                                ::  HMAC-SHA1
  |=  [key=@ mes=@]
  =+  ip=(fil 3 64 0x36)
  =+  op=(fil 3 64 0x5c)
  =+  ^=  kex
      ?:  (gth (met 3 key) 64)
        (lsh 3 44 (shan (swap 3 key)))
      (lsh 3 (sub 64 (met 3 key)) (swap 3 key))
  =+  inn=(shan (swap 3 (cat 3 (swap 3 mes) (mix ip kex))))
  (shan (swap 3 (cat 3 inn (mix op kex))))
::
```

XX document

##section 3bC, UTC                      ::  Gregorianonly

###++dawn

```
++  dawn                                                ::  Jan 1 weekday
  |=  yer=@ud
  =+  yet=(sub yer 1)
  %-  mod  :_  7
  :(add 1 (mul 5 (mod yet 4)) (mul 4 (mod yet 100)) (mul 6 (mod yet 400)))
::
```

XX document

###++daws

```
++  daws                                                ::  date weekday
  |=  yed=date
  %-  mod  :_  7
  (add (dawn y.yed) (sub (yawn [y.yed m.yed d.t.yed]) (yawn y.yed 1 1)))
::
```

XX document

###++deal

```
++  deal                                                ::  to leap sec time
  |=  yer=@da
  =+  n=0
  =+  yud=(yore yer)
  |-  ^-  date
  ?:  (gte yer (add (snag n lef:yu) ~s1))
    (yore (year yud(s.t (add n s.t.yud))))
  ?:  &((gte yer (snag n lef:yu)) (lth yer (add (snag n lef:yu) ~s1)))
    yud(s.t (add +(n) s.t.yud))
  ?:  =(+(n) (lent lef:yu))
    (yore (year yud(s.t (add +(n) s.t.yud))))
  $(n +(n))
::
```

XX document

###++lead

```
++  lead                                                ::  from leap sec time
  |=  ley=date
  =+  ler=(year ley)
  =+  n=0
  |-  ^-  @da
  =+  led=(sub ler (mul n ~s1))
  ?:  (gte ler (add (snag n les:yu) ~s1))
    led
  ?:  &((gte ler (snag n les:yu)) (lth ler (add (snag n les:yu) ~s1)))
    ?:  =(s.t.ley 60)
      (sub led ~s1)
    led
  ?:  =(+(n) (lent les:yu))
    (sub led ~s1)
  $(n +(n))
::
```

XX document

###++dust

```
++  dust                                                ::  print UTC format
  |=  yed=date
  ^-  tape
  =+  wey=(daws yed)
  ;:  weld
      `tape`(snag wey (turn wik:yu |=(a=tape (scag 3 a))))
      ", "  ~(rud at d.t.yed)  " "
      `tape`(snag (dec m.yed) (turn mon:yu |=(a=tape (scag 3 a))))
      " "  (scag 1 ~(rud at y.yed))  (slag 2 ~(rud at y.yed))  " "
      ~(rud at h.t.yed)  ":"  ~(rud at m.t.yed)  ":"  ~(rud at s.t.yed)
      " "  "+0000"
  ==
::
```

XX document

###++stud

```
++  stud                                                ::  parse UTC format
  |=  cud=tape
  ^-  (unit date)
  =-  ?~  tud  ~ 
      `[[%.y &3.u.tud] &2.u.tud &1.u.tud &4.u.tud &5.u.tud &6.u.tud ~]
  ^=  tud
  %+  rust  cud
  ;~  plug
    ;~(pfix (stun [5 5] next) dim:ag)
  ::
    %+  cook
      |=  a=tape
      =+  b=0
      |-  ^-  @
      ?:  =(a (snag b (turn mon:yu |=(a=tape (scag 3 a)))))
          +(b)
      $(b +(b))
    (ifix [ace ace] (star alf))
  ::
    ;~(sfix dim:ag ace)  
    ;~(sfix dim:ag col)
    ;~(sfix dim:ag col)  
    dim:ag  
    (cold ~ (star next))
  ==
::
```

XX document

###++unt

```
++  unt                                                 ::  UGT to UTC time
  |=  a=@
  (div (sub a ~1970.1.1) (bex 64))
::
```

XX document

###++yu

```
++  yu                                                  ::  UTC format constants
  |%
```

XX document

###++mon

```
  ++  mon  ^-  (list tape)
    :~  "January"  "February"  "March"  "April"  "May"  "June"  "July"
        "August"  "September"  "October"  "November"  "December"
    ==
  ::
```

XX document

###++wik

```
  ++  wik  ^-  (list tape)
    :~  "Sunday"  "Monday"  "Tuesday"  "Wednesday"  "Thursday"
        "Friday"  "Saturday"
    ==
  ::
```

XX document

###++les

```
  ++  les  ^-  (list ,@da)
    :~  ~2012.7.1  ~2009.1.1  ~2006.1.1  ~1999.1.1  ~1997.7.1  ~1996.1.1
        ~1994.7.1  ~1993.7.1  ~1992.7.1  ~1991.1.1  ~1990.1.1  ~1988.1.1
        ~1985.7.1  ~1983.7.1  ~1982.7.1  ~1981.7.1  ~1980.1.1  ~1979.1.1
        ~1978.1.1  ~1977.1.1  ~1976.1.1  ~1975.1.1  ~1974.1.1  ~1973.1.1
        ~1972.7.1
    ==
```

XX document

###++lef

```
  ++  lef  ^-  (list ,@da)
    :~  ~2012.6.30..23.59.59   ~2008.12.31..23.59.58
        ~2005.12.31..23.59.57  ~1998.12.31..23.59.56
        ~1997.6.30..23.59.55   ~1995.12.31..23.59.54
        ~1994.6.30..23.59.53   ~1993.6.30..23.59.52
        ~1992.6.30..23.59.51   ~1990.12.31..23.59.50
        ~1989.12.31..23.59.49  ~1987.12.31..23.59.48
        ~1985.6.30..23.59.47   ~1983.6.30..23.59.46
        ~1982.6.30..23.59.45   ~1981.6.30..23.59.44
        ~1979.12.31..23.59.43  ~1978.12.31..23.59.42
        ~1977.12.31..23.59.41  ~1976.12.31..23.59.40
        ~1975.12.31..23.59.39  ~1974.12.31..23.59.38
        ~1973.12.31..23.59.37  ~1972.12.31..23.59.36
        ~1972.6.30..23.59.35
    ==
::
```

XX document

##section 3bD, JSON and XML

###++moon

```
++  moon                                                ::  mime type to text
  |=  myn=mite
  %+  rap
    3
  |-  ^-  tape
  ?~  myn  ~
  ?:  =(~ t.myn)  (trip i.myn)
  (weld (trip i.myn) `tape`['/' $(myn t.myn)])
::
```

XX document

###++perk

```
++  perk                                                ::  pars cube fork
  |*  a=(pole ,@tas)
  ?~  a  fail
  ;~  pose 
    (cold -.a (jest -.a))
    $(a +.a)
  ==
::
```

XX document

###++poja

```
++  poja                                                ::  parse JSON
  |%
```

XX document

###++apex

```
  ++  apex
    =+  spa=;~(pose comt whit)
    %+  knee  *manx  |.  ~+
    %+  ifix  [(star spa) (star spa)]
    ;~  pose
      %+  sear  |=([a=marx b=marl c=mane] ?.(=(c n.a) ~ (some [a b])))
        ;~(plug head (more (star comt) ;~(pose apex chrd)) tail)
      empt
    == 
  :: 
```

XX document

###++valu

```
  ++  valu                                              ::  JSON value
    %+  knee  *json  |.  ~+
    ;~  pfix  spac
      ;~  pose
        (cold ~ (jest 'null'))
        (jify %b bool)
        (jify %s stri)
        (cook |=(s=tape [%n p=(rap 3 s)]) numb)
        abox
        obox
      ==
    ==
  ::  JSON arrays
```

XX document

###++arra

```
  ++  arra  (ifix [sel (ws ser)] (more (ws com) valu))
```

XX document

###++abox

```
  ++  abox  (cook |=(elts=(list json) [%a p=elts]) arra)
  ::  JSON objects
```

XX document

###++pair

```
  ++  pair  ;~((comp |=([k=@ta v=json] [k v])) ;~(sfix (ws stri) (ws col)) valu)
```

XX document

###++obje

```
  ++  obje  (ifix [(ws kel) (ws ker)] (more (ws com) pair))
```

XX document

###++obox

```
  ++  obox  (cook |=(s=(list ,[@ta json]) [%o p=(mo s)]) obje)
  ::  JSON booleans
```

XX document

###++bool

```
  ++  bool  ;~(pose (cold & (jest 'true')) (cold | (jest 'false')))
  ::  JSON strings
```

XX document

###++stri

```
  ++  stri
    (cook |=(s=(list ,@) (rap 3 s)) (ifix [doq doq] (star jcha)))
```

XX document

###++jcha

```
  ++  jcha                                               :: character in string
    ;~  pose
      esca
      ;~  pose
        :: Non-escape string characters
        (shim 32 33)
        (shim 35 91)
        (shim 93 126)
        (shim 128 255)
      ==
    ==
```

XX document

###++esca

```
  ++  esca                                               :: Escaped character
    ;~  pfix  bas
      ;~  pose
        doq
        fas
        soq
        bas
        (cold 8 (just 'b'))
        (cold 9 (just 't'))
        (cold 10 (just 'n'))
        (cold 12 (just 'f'))
        (cold 13 (just 'r'))
        ;~(pfix (just 'u') (cook tuft qix:ab)) :: Convert 4-digit hex to UTF-8
      ==
    ==
  ::  JSON numbers
```

XX document

###++numb

```
  ++  numb
    ;~  (comp twel)
      (mayb (piec hep))
      ;~  pose
        (piec (just '0'))
        ;~((comp twel) (piec (shim '1' '9')) digs)
      ==
      (mayb frac)
      (mayb expo)
    ==
```

XX document

###++digs

```
  ++  digs  (star (shim '0' '9'))
```

XX document

###++expo

```
  ++  expo                                               :: Exponent part
    ;~  (comp twel)
      (piec (mask "eE"))
      (mayb (piec (mask "+-")))
      digs
    ==
```

XX document

###++frac

```
  ++  frac                                               :: Fractional part
    ;~  (comp twel)
      (piec dot)
      digs
    ==
  ::  whitespace
```

XX document

###++spac

```
  ++  spac  (star (mask [`@`9 `@`10 `@`13 ' ' ~]))
```

XX document

###++ws

```
  ++  ws  |*(sef=_rule ;~(pfix spac sef))
  ::  plumbing
```

XX document

###++jify

```
  ++  jify  |*([t=@ta r=_rule] (cook |*([v=*] [t p=v]) r))
```

XX document

###++mayb

```
  ++  mayb  |*(bus=_rule ;~(pose bus (easy "")))
```

XX document

###++twel

```
  ++  twel  |=([a=tape b=tape] (weld a b))
```

XX document

###++piec

```
  ++  piec
    |*  bus=_rule
    (cook |=(a=@ [a ~]) bus)
::
```

XX document

###++pojo

```
++  pojo                                                ::  print json
  |=  val=json
  ^-  tape
  ?~  val  "null"
  ?-    -.val
      %a
    ;:  weld
      "["
      =|  rez=tape
      |-  ^+  rez
      ?~  p.val  rez
      $(p.val t.p.val, rez :(weld rez ^$(val i.p.val) ?~(t.p.val ~ ",")))
      "]"
    ==
 ::
      %b  ?:(p.val "true" "false")
      %n  (trip p.val)
      %s
    ;:  welp
      "\""
      %+  reel
        (turn (trip p.val) jesc)
      |=([p=tape q=tape] (welp +<))
      "\""
    ==
      %o
    ;:  welp
      "\{"
      =+  viz=(~(tap by p.val) ~)
      =|  rez=tape
      |-  ^+  rez
      ?~  viz  rez
      %=    $
          viz  t.viz
          rez
        :(welp rez "\"" (trip p.i.viz) "\":" ^$(val q.i.viz) ?~(t.viz ~ ","))
      ==
      "}"
    ==
  ==
::
```

XX document

###++jo

```
++  jo                                                  ::  json reparser
  =>  |%  ++  grub  (unit ,*) 
          ++  fist  $+(json grub)
  |%
```

Contains converters of ++json to well-typed structures.

A `fist` is a gate that produces some manner of unit from json. Most arms in
`++jo` are fists, or produce them.

###++ar

```
  ++  ar                                                ::  array as list
    |*  wit=fist
    |=  jon=json
    ?.  ?=([%a *] jon)  ~
    %-  zl
    |-  
    ?~  p.jon  ~
    [i=(wit i.p.jon) t=$(p.jon t.p.jon)]
  ::
```

Parse JSON array as typed list.

```
~zod/try=> :type; ((ar ni):jo a/~[n/'1' n/'2'])
[~ u=~[1 2]]
{[%~ u=it(@)] %~}
```

###++at

```
  ++  at                                                ::  array as tuple
    |*  wil=(pole fist)
    |=  jon=json
    ?.  ?=([%a *] jon)  ~
    =+  raw=((at-raw wil) p.jon)
    ?.((za raw) ~ (some (zp raw)))
  ::
```

Parse JSON array as a fixed-length tuple.

```
~zod/try=> :type; ((ar ni):jo a/~[n/'3' s/'to' n/''])
[~ u=[3 'to' 4]]
{[%~ u=[@ @ta @]] %~}
```

###++bo

```
  ++  bo                                                ::  boolean
    |=(jon=json ?.(?=([%b *] jon) ~ [~ u=p.jon]))
  ::
```


Parse JSON boolean.

###++bu

```
  ++  bu                                                ::  boolean not
    |=(jon=json ?.(?=([%b *] jon) ~ [~ u=!p.jon]))
  ::
```

Parse inverse of JSON boolean.

XX  Finish

###++cu

```
  ++  cu                                                ::  transform
    |*  [poq=$+(* *) wit=fist]
    |=  jon=json
    (bind (wit jon) poq)
  ::
```

XX document

###++da

```
  ++  da                                                ::  UTC date
    |=  jon=json
    ?.  ?=([%s *] jon)  ~
    (bind (stud (trip p.jon)) |=(a=date (year a)))
  ::
```

XX document

###++mu

```
  ++  mu                                                ::  true unit
    |*  wit=fist
    |=  jon=json
    ?~(jon (some ~) (wit jon))
  ::
```

XX document

###++ne

```
  ++  ne                                                ::  number as real
    |=  jon=json
    ^-  (unit ,@rd)
    !!
  ::
```

XX document

###++ni

```
  ++  ni                                                ::  number as integer
    |=  jon=json 
    ?.  ?=([%n *] jon)  ~
    (slaw %ui (cat 3 '0i' p.jon))
  ::
```

XX document

###++no

```
  ++  no                                                ::  number as cord
    |=  jon=json
    ?.  ?=([%n *] jon)  ~
    (some p.jon)
  ::
```

XX document

###++of

```
  ++  of                                                ::  object as frond
    |*  wer=(pole ,[cord fist])
    |=  jon=json
    ?.  ?=([%o [@ *] ~ ~] jon)  ~
    |-
    ?~  wer  ~
    ?:  =(-.-.wer p.n.p.jon)  
      ((pe -.-.wer +.-.wer) q.n.p.jon)
    ((of +.wer) jon)
  ::
```

XX document

###++ot

```
  ++  ot                                                ::  object as tuple
    |*  wer=(pole ,[cord fist])
    |=  jon=json
    ?.  ?=([%o *] jon)  ~
    =+  raw=((ot-raw wer) p.jon)
    ?.((za raw) ~ (some (zp raw)))
  ::
```

XX document

###++ot

```
  ++  ot                                                ::  object as tuple
    |*  wer=(pole ,[cord fist])
    |=  jon=json
    ?.  ?=([%o *] jon)  ~
    =+  raw=((ot-raw wer) p.jon)
    ?.((za raw) ~ (some (zp raw)))
  ::
```

XX document

###++om

```
  ++  om                                                ::  object as map
    |*  wit=fist
    |=  jon=json
    ?.  ?=([%o *] jon)  ~
    %-  zm
    |-  
    ?~  p.jon  ~
    [n=[p=p.n.p.jon q=(wit q.n.p.jon)] l=$(p.jon l.p.jon) r=$(p.jon r.p.jon)]
  ::
```

XX document

###++pe

```
  ++  pe                                                ::  prefix
    |*  [pre=* wit=fist]
    (cu |*(a=* [pre a]) wit)
  ::
```

XX document

###++sa

```
  ++  sa                                                ::  string as tape
    |=  jon=json
    ?.(?=([%s *] jon) ~ (some (trip p.jon)))
  ::
```

XX document

###++so

```
  ++  so                                                ::  string as cord
    |=  jon=json
    ?.(?=([%s *] jon) ~ (some p.jon))
  ::
```

XX document

###++su

```
  ++  su                                                ::  parse string
    |*  sab=rule
    |=  jon=json
    ?.  ?=([%s *] jon)  ~
    (rush p.jon sab)
  ::
```

XX document

###++ul

```
  ++  ul  |=(jon=json ?~(jon (some ~) ~))               ::  null
```

XX document

###++za

```
  ++  za                                                ::  full unit pole
    |*  pod=(pole (unit))
    ?~  pod  &
    ?~  -.pod  |
    (za +.pod)
  ::
```

XX document

###++zl

```
  ++  zl                                                ::  collapse unit list
    |*  lut=(list (unit))
    ?.  |-  ^-  ?
        ?~(lut & ?~(i.lut | $(lut t.lut)))
      ~
    %-  some
    |-
    ?~  lut  ~
    [i=u:+.i.lut t=$(lut t.lut)]
  ::
```

XX document

###++zp

```
  ++  zp                                                ::  unit tuple
    |*  but=(pole (unit))
    ?~  but  !!
    ?~  +.but  
      u:->.but
    [u:->.but (zp +.but)]
  ::
```

XX document

###++zt

```
  ++  zt                                                ::  unit tuple
    |*  lut=(list (unit))
    ?:  =(~ lut)  ~
    ?.  |-  ^-  ?
        ?~(lut & ?~(i.lut | $(lut t.lut)))
      ~
    %-  some
    |-
    ?~  lut  !!
    ?~  t.lut  u:+.i.lut
    [u:+.i.lut $(lut t.lut)]
  ::
```

XX document

###++zm

```
  ++  zm                                                ::  collapse unit map
    |*  lum=(map term (unit))
    ?.  |-  ^-  ?
        ?~(lum & ?~(q.n.lum | &($(lum l.lum) $(lum r.lum))))
      ~
    %-  some
    |-
    ?~  lum  ~
    [[p.n.lum u:+.q.n.lum] $(lum l.lum) $(lum r.lum)]
::
```

XX document

###++joba

```
++  joba
  |=  [p=@t q=json]
  ^-  json
  [%o [[p q] ~ ~]]
::
```

XX document

###++jobe

```
++  jobe
  |=  a=(list ,[p=@t q=json])
  ^-  json
  [%o (~(gas by *(map ,@t json)) a)]
::
```

XX document

###++jape

```
++  jape
  |=  a=tape
  ^-  json
  [%s (crip a)]
::
```

XX document

###++jone

```
++  jone
  |=  a=@
  ^-  json
  :-  %n
  ?:  =(0 a)  '0'
  (crip (flop |-(^-(tape ?:(=(0 a) ~ [(add '0' (mod a 10)) $(a (div a 10))])))))
::
```

XX document

###++jesc

```
++  jesc
  |=  a=@  ^-  tape
  ?+  a  [a ~]
    10  "\\n"
    34  "\\\""
    92  "\\\\"
  ==
::
```

XX document

###++scanf

```
++  scanf                                              ::  formatted scan
  |*  [tape (pole ,_:/(*$&(_rule tape)))]
  =>  .(+< [a b]=+<)
  (scan a (parsf b))
```

Scan with `;"`-interpolated parsers.

```
~zod/try=> `[p=@ud q=@ud]`(scanf "Score is 5 to 2" [;"Score is {n} to {n}"]:n=dim:ag)
[p=5 q=2]
```

```
~zod/try=> =n ;~(pfix (star (just '0')) (cook |=(@ud +<) dim:ag))
~zod/try=> (scanf "2014-08-12T23:10:58.931Z" ;"{n}\-{n}\-{n}T{n}:{n}:{n}.{n}Z")
[2.014 8 12 23 10 58 931]
~zod/try=> =dat (scanf "2014-08-12T23:10:58.931Z" ;"{n}\-{n}\-{n}T{n}:{n}:{n}.{n}Z")
~zod/try=> `@da`(year `date`dat(- [%& -.dat], |6 ~[(div (mul |6.dat (bex 16)) 1.000)]))
~2014.8.12..23.10.58..ee56
```

###++parsf

```
++  parsf                                              ::  make parser from:
  |^  |*  a=(pole ,_:/(*$&(_rule tape)))               ::  ;"chars{rule}chars"
      %-  cook  :_  (bill (norm a))
      |*  (list)
      ?~  +<  ~
      ?~  t  i
      [i $(+< t)]
  ::
  ::  .=  (norm [;"{n}, {n}"]:n=dim:ag)  ~[[& dim] [| ", "] [& dim]]:ag
```

`parsf` generates a `_rule` from a tape with rules embedded in it, literal
sections being matched verbatim. The parsed type is a tuple of the embedded
rules' results.

Two intermediate arms are used:

####++norm

```
  ++  norm                                             
    |*  (pole ,_:/(*$&(_rule tape)))
    ?~  +<  ~
    =>  .(+< [i=+<- t=+<+])
    :_  t=$(+< t)
    =+  rul=->->.i
    ^=  i
    ?~  rul     [%| p=rul]
    ?~  +.rul   [%| p=rul]
    ?@  &2.rul  [%| p=;;(tape rul)]
    [%& p=rul]
  ::
  ::  .=  (bill ~[[& dim] [| ", "] [& dim]]:ag)
  ::  ;~(plug dim ;~(pfix com ace ;~(plug dim (easy)))):ag
```

`norm` converts a `;"` pole of `[[%~. [%~. ?(tape _rule)] ~] ~]` into a more
convenient list of discriminated tapes and rules.

####++bill

```
  ++  bill
    |*  (list (each ,_rule tape))
    ?~  +<  (easy ~)
    ?:  ?=(| -.i)  ;~(pfix (jest (crip p.i)) $(+< t))
    %+  cook  |*([* *] [i t]=+<)
    ;~(plug p.i $(+< t))
::
```

`bill` builds a parser out of rules and tapes, ignoring the literal sections
and producing a list of the rules' results.

###++taco

```
++  taco                                                ::  atom to octstream
  |=  tam=@  ^-  octs
  [(met 3 tam) tam]
::
```

XX document

###++tact

```
++  tact                                                ::  tape to octstream
  |=  tep=tape  ^-  octs
  (taco (rap 3 tep))
::
```

XX document

###++tell

```
++  tell                                                ::  wall to octstream
  |=  wol=wall  ^-  octs
  =+  buf=(rap 3 (turn wol |=(a=tape (crip (weld a `tape`[`@`10 ~])))))
  [(met 3 buf) buf]
::
```

XX document

###++txml

```
++  txml                                                ::  string to xml
  |=  tep=tape  ^-  manx
  [[%$ [%$ tep] ~] ~]
::
```

XX document

###++xmla

```
++  xmla                                                ::  attributes to tape
  |=  [tat=mart rez=tape]
  ^-  tape
  ?~  tat  rez
  =+  ryq=$(tat t.tat)
  :(weld (xmln n.i.tat) "=\"" (xmle | v.i.tat '"' ?~(t.tat ryq [' ' ryq])))
::
```

XX document

###++xmle

```
++  xmle                                                ::  escape for xml
  |=  [unq=? tex=tape rez=tape]
  ?:  unq
    (weld tex rez)
  =+  xet=`tape`(flop tex)
  |-  ^-  tape
  ?~  xet  rez
  %=    $
    xet  t.xet
    rez  ?-  i.xet
           34  ['&' 'q' 'u' 'o' 't' ';' rez]
           38  ['&' 'a' 'm' 'p' ';' rez]
           39  ['&' '#' '3' '9' ';' rez]
           60  ['&' 'l' 't' ';' rez]
           62  ['&' 'g' 't' ';' rez]
           *   [i.xet rez]
         ==
  ==
::
```

XX document

###++xmln

```
++  xmln                                                ::  name to tape
  |=  man=mane  ^-  tape
  ?@  man  (trip man)
  (weld (trip -.man) `tape`[':' (trip +.man)])
::
```

XX document

###++xmll

```
++  xmll                                                ::  nodelist to tape
  |=  [unq=? lix=(list manx) rez=tape]
  |-  ^-  tape
  ?~  lix  rez
  (xmlt unq i.lix $(lix t.lix))
::
```

XX document

###++xmlt

```
++  xmlt                                                ::  node to tape
  |=  [unq=? mex=manx rez=tape]
  ^-  tape
  ?:  ?=([%$ [[%$ *] ~]] g.mex)
    (xmle unq v.i.a.g.mex rez)
  =+  man=`mane`-.g.mex
  =.  unq  |(unq =(%script man) =(%style man))
  =+  tam=(xmln man)
  =+  end=:(weld "</" tam ">" rez)
  =+  bod=['>' (xmll unq c.mex :(weld "</" tam ">" rez))]
  =+  att=`mart`a.g.mex
  :-  '<'
  %+  weld  tam
  `_tam`?~(att bod [' ' (xmla att bod)])
::
```

XX document

###++xmlp

```
++  xmlp                                                ::  xml parser
  |%
```

XX document

###++apex

```
  ++  apex
    =+  spa=;~(pose comt whit)
    %+  knee  *manx  |.  ~+
    %+  ifix  [(star spa) (star spa)]
    ;~  pose
      %+  sear  |=([a=marx b=marl c=mane] ?.(=(c n.a) ~ (some [a b])))
        ;~(plug head (more (star comt) ;~(pose apex chrd)) tail)
      empt
    == 
  :: 
```

XX document

###++attr

```
  ++  attr                                              ::  attribute
    %+  knee  *mart  |.  ~+ 
    %-  star
    ;~  pfix  (plus whit)
      ;~  plug  name  
        ;~  pfix  tis
          ;~  pose 
              (ifix [doq doq] (star ;~(less doq escp)))
              (ifix [soq soq] (star ;~(less soq escp)))
          ==  
        ==
      ==  
    ==
  ::
```

XX document

###++chrd

```
  ++  chrd                                              ::  character data
    %+  knee  *manx  |.  ~+
    %+  cook  |=(a=tape :/(a))
    (plus ;~(less soq doq ;~(pose (just `@`10) escp)))
  ::
```

XX document

###++comt

```
  ++  comt  %+  ifix  [(jest '<!--') (jest '-->')]      ::  comments 
            (star ;~(less (jest '-->') ;~(pose whit prn)))
  ::
```

XX document

###++escp

```
  ++  escp
    ;~  pose
      ;~(less gal gar pam prn)
      (cold '>' (jest '&gt;'))
      (cold '<' (jest '&lt;'))
      (cold '&' (jest '&amp;'))
      (cold '"' (jest '&quot;'))
      (cold '\'' (jest '&apos;'))
    ==
```

XX document

###++empt

```
  ++  empt                                              ::  self-closing tag
    %+  ifix  [gal ;~(plug (stun [0 1] ace) (jest '/>'))] 
    ;~(plug ;~(plug name attr) (cold ~ (star whit)))  
  ::
```

XX document

###++head

```
  ++  head                                              ::  opening tag
    %+  knee  *marx  |.  ~+
    (ifix [gal gar] ;~(plug name attr))
  ::
```

XX document

###++name

```
  ++  name                                              ::  tag name 
    %+  knee  *mane  |.  ~+
    =+  ^=  chx
        %+  cook  crip 
        ;~  plug 
            ;~(pose cab alf) 
            (star ;~(pose cab dot alp))
        ==
    ;~(pose ;~(plug ;~(sfix chx col) chx) chx)
  ::
```

XX document

###++tail

```
  ++  tail  (ifix [(jest '</') gar] name)               ::  closing tag
```

XX document

###++whit

```
  ++  whit  (mask ~[`@`0x20 `@`0x9 `@`0xa])             ::  whitespace
::
```

XX document

##section 3bE, tree sync

###++invert

``````

XX document

###++cosh

```
++  cosh                                                ::  locally rehash
  |=  ank=ankh                                          ::  NB v/unix.c
  ank(p rehash:(zu ank))
::
```

XX document

###++cost

```
++  cost                                                ::  new external patch
  |=  [bus=ankh ank=ankh]                               ::  NB v/unix.c
  ^-  soba
  :-  [p.ank p.bus] 
  %-  flop
  myz:(change-tree:(zu ank) %c bus)
::
```

XX document

###++loth

```
++  loth
  |=  pat=(map path ,*)
  ^-  (set path)
  %+  roll  (~(tap by pat) ~)
  |=  [[p=path *] q=(set path)]
  %.  p  %~  put  in  q
::
```

XX document

###++luth

```
++  luth
  |=  [p=(map path ,*) q=(map path ,*)]                 ::  merge keysets
  ^-  (set path)
  (~(uni in (loth p)) (loth q))
::
```

XX document

###++blob

``````

XX document

###++ze

```
++  ze
  |_  [lim=@da dome rang]
```

XX document

###++aeon

``````

XX document

###++aeon

``````

XX document

###++make

``````

XX document

###++tako

``````

XX document

###++lobe

``````

XX document

###++lobe

``````

XX document

###++make

``````

XX document

###++make

``````

XX document

###++blob

``````

XX document

###++blob

``````

XX document

###++diff

``````

XX document

###++lobes

``````

XX document

###++case

``````

XX document

###++as

``````

XX document

###++reachable

``````

XX document

###++new

``````

XX document

###++new

``````

XX document

###++reachable

``````

XX document

###++takos

``````

XX document

###++lobes

``````

XX document

###++make

``````

XX document

###++query

```
  ++  query                                             ::    query:ze
    |=  ren=?(%u %v %x %y %z)                           ::  endpoint query
    ^-  (unit ,*)
    ?-  ren
      %u  [~ `rang`+<+>.query]
      %v  [~ `dome`+<+<.query]
      %x  ?~(q.ank ~ [~ q.u.q.ank])
      %y  [~ as-arch]
      %z  [~ ank]
    ==
  ::
```

XX document

###++rewind

```
  ++  rewind                                            ::    rewind:ze
    |=  yon=aeon                                        ::  rewind to aeon
    ^+  +>
    ?:  =(let yon)  +>
    ?:  (gth yon let)  !!                               ::  don't have version
    +>(ank (checkout-ankh q:(aeon-to-yaki yon)), let yon)
  ::
```

XX document

###++update

``````

XX document

###++apply

``````

XX document

###++checkout

``````

XX document

###++forge

```
  ++  forge                                         ::  %forge
    |=  [p=yaki q=yaki s=[ship desk] t=[ship desk]]
    ^-  (map path blob)
    =+  r=(~(tap in (find-merge-points p q)) ~)
    ?~  r
      ~|(%forge-no-ancestor !!)
    %-  |=  [r=yaki lut=(map lobe blob) hat=(map tako yaki)]
        =.  lat  lut
        =.  hut  hat
        (meld p q r & s t)                          ::  fake merge
    %+  roll  t.r                                   ::  fake ancestor
    |=  [par=yaki [for=_i.r lut=_lat hat=_hut]]
    =.  lat  lut
    =+  ^=  far
        ^-  (map path lobe)
        %-  ~(tur by (forge par for s t))
        |=  [k=path v=blob]  (blob-to-lobe v)
    =+  u=(make-yaki [r.par r.for ~] far `@da`0)    ::  fake yaki
    :-  u
    :_  (~(put by hat) r.u u)
    =<  -
    %-  update-lat
    :_  ~
    %-  ~(tur by q.u)
    |=  [path k=lobe]
    (lobe-to-blob k)
  ::
  ::  actual merge
  ::
```

XX document

###++forge

```
  ++  forge                                         ::  %forge
    |=  [p=yaki q=yaki s=[ship desk] t=[ship desk]]
    ^-  (map path blob)
    =+  r=(~(tap in (find-merge-points p q)) ~)
    ?~  r
      ~|(%forge-no-ancestor !!)
    %-  |=  [r=yaki lut=(map lobe blob) hat=(map tako yaki)]
        =.  lat  lut
        =.  hut  hat
        (meld p q r & s t)                          ::  fake merge
    %+  roll  t.r                                   ::  fake ancestor
    |=  [par=yaki [for=_i.r lut=_lat hat=_hut]]
    =.  lat  lut
    =+  ^=  far
        ^-  (map path lobe)
        %-  ~(tur by (forge par for s t))
        |=  [k=path v=blob]  (blob-to-lobe v)
    =+  u=(make-yaki [r.par r.for ~] far `@da`0)    ::  fake yaki
    :-  u
    :_  (~(put by hat) r.u u)
    =<  -
    %-  update-lat
    :_  ~
    %-  ~(tur by q.u)
    |=  [path k=lobe]
    (lobe-to-blob k)
  ::
  ::  actual merge
  ::
```

XX document

###++reduce

``````

XX document

###++future

``````

XX document

###++add

``````

XX document

###++find

``````

XX document

###++clean

```
  ++  clean                                          ::  clean
    |=  wig=(urge)
    ^-  (urge)
    ?~  wig  ~
    ?~  t.wig  wig
    ?:  ?=(%& -.i.wig)
      ?:  ?=(%& -.i.t.wig)
        $(wig [[%& (add p.i.wig p.i.t.wig)] t.t.wig])
      [i.wig $(wig t.wig)]
    ?:  ?=(%| -.i.t.wig)
      $(wig [[%| (welp p.i.wig p.i.t.wig) (welp q.i.wig q.i.t.wig)] t.t.wig])
    [i.wig $(wig t.wig)]
  ::
```

XX document

###++match

``````

XX document

###++annotate

```
  ++  annotate                                      ::  annotate conflict
    |=  [us=[ship desk] th=[ship desk] p=(list ,@t) q=(list ,@t) r=(list ,@t)]
    ^-  (list ,@t)
    %-  zing
    ^-  (list (list ,@t))
    %-  flop
    ^-  (list (list ,@t))
    :-  :_  ~
        %^  cat  3  '<<<<<<<<<<<<' 
        %^  cat  3  ' '
        %^  cat  3  `@t`(scot %p -.us)
        %^  cat  3  '/'
        +.us
    :-  p
    :-  ~['------------']
    :-  r
    :-  ~['++++++++++++']
    :-  q
    :-  :_  ~
        %^  cat  3  '>>>>>>>>>>>>' 
        %^  cat  3  ' '
        %^  cat  3  `@t`(scot %p -.th)
        %^  cat  3  '/'
        +.th
    ~
  ::
```

XX document

    :-  ~['++++++++++++']

###++match

``````

XX document

###++qeal

```
  ++  qeal                                          ::  merge p,q
    |*  [us=[ship desk] th=[ship desk] pat=path p=miso q=miso r=(list) con=?]
    ^-  miso                                        ::  in case of conflict
    ~|  %qeal-fail
    ?>  ?=(%mut -.p)
    ?>  ?=(%mut -.q)
    ?>  ?=(%c -.q.p.p)
    ?>  ?=(%c -.q.p.q)
    =+  s=(clean p.q.p.p)
    =+  t=(clean p.q.p.q)
    :-  %mut
    :-  %c  ::  todo is this p.p.p?
    :-  %c
    |-  ^-  (urge)
    ::?~  s  ?:  (qual t)  t
    ::       ~|  %qail-conflict  !!
    ::?~  t  ?:  (qual s)  s
    ::       ~|  %qail-conflict  !!
    ?~  s  t
    ?~  t  s
    ?-    -.i.s
        %&
      ?-    -.i.t
          %&
        ?:  =(p.i.s p.i.t)
          [i.s $(s t.s, t t.t, r (slag p.i.s r))]
        ?:  (gth p.i.s p.i.t)
          [i.t $(t t.t, p.i.s (sub p.i.s p.i.t), r (slag p.i.t r))]
        [i.s $(s t.s, p.i.t (sub p.i.t p.i.s), r (slag p.i.s r))]
          %|
        ?:  =(p.i.s (lent p.i.t))
          [i.t $(s t.s, t t.t, r (slag p.i.s r))]
        ?:  (gth p.i.s (lent p.i.t))
          :-  i.t 
          $(t t.t, p.i.s (sub p.i.s (lent p.i.t)), r (slag (lent p.i.t) r))
        ?.  con  ~|  %quil-conflict  !!           ::  conflict
        ~&  [%quil-conflict-soft pat]
        =+  mar=(match-conflict us th s t r)
        [[%| p.mar] $(s p.q.mar, t q.q.mar, r r.q.mar)]
      ==
        %|
      ?-    -.i.t
          %|
        ?.  con  ~|  %quil-conflict  !!
        ~&  [%quil-conflict-soft pat]
        =+  mar=(match-conflict us th s t r)
        [[%| p.mar] $(s p.q.mar, t q.q.mar, r r.q.mar)]
          %&
        ?:  =(p.i.t (lent p.i.s))
          [i.s $(s t.s, t t.t, r (slag p.i.t r))]
        ?:  (gth p.i.t (lent p.i.s))
          :-  i.s
          $(s t.s, p.i.t (sub p.i.t (lent p.i.s)), r (slag (lent p.i.s) r))
        ?.  con  ~|  %quil-conflict  !!
        ~&  [%quil-conflict-soft pat]
        =+  mar=(match-conflict us th s t r)
        [[%| p.mar] $(s p.q.mar, t q.q.mar, r r.q.mar)]
      ==
    ==
```

XX document

###++quil

```
  ++  quil                                          ::  merge p,q
    |=  $:  us=[ship desk]
            th=[ship desk]
            pat=path
            p=(unit miso)
            q=(unit miso)
            r=(unit (list))
            con=?
        ==
    ^-  (unit miso)
    ?~  p  q                                        ::  trivial
    ?~  q  p                                        ::  trivial
    ?-  -.u.p
      %ins  ?>  ?=(%ins -.u.q)
            ?.  con  !!
            %-  some
            :-  %ins
            %-  roly
            %-  annotate
            :-  us 
            :-  th
            :-  (lore ((hard ,@) p.u.p)) 
            :-  (lore ((hard ,@) p.u.q))
            ~
      %del  p
      %mut  ?>  ?=(%mut -.u.q)
            %-  some
            %^  qeal  us  th
            :^  pat  u.p  u.q                       ::  merge p,q
            :-  %-  need  r
            con
    ==
  ::
```

XX document

###++meld

```
  ++  meld                                          ::  merge p,q from r
    |=  [p=yaki q=yaki r=yaki con=? us=[ship desk] th=[ship desk]]
    ^-  (map path blob)
    =+  s=(diff-yakis r p)
    =+  t=(diff-yakis r q)
    =+  lut=(luth s t)
    %-  |=  res=(map path blob)                        ::  add old
        ^-  (map path blob)
        %-  ~(uni by res)
        %-  mo
        %+  turn  
          %+  skip  (~(tap by q.r) ~)                  ::  loop through old
          |=  [pat=path bar=lobe]  ^-  ?
          (~(has in lut) pat)                          ::  skip updated
        |=  [pat=path bar=lobe]  ^-  [path blob]
        [pat (lobe-to-blob bar)]                       ::  lookup objects
    %+  roll  (~(tap in (luth s t)) ~)
    |=  [pat=path res=(map path blob)]
    =+  ^=  v
        %-  need
        %^  quil  us  th
        :-  pat
        :+  (~(get by s) pat)
          (~(get by t) pat)
        :_  con
        %-  %-  lift  lore
        %-  %-  lift  %-  hard  ,@                     ::  for %c
        %-  %-  lift  lobe-to-noun
        %-  ~(get by q.r)
        pat
    ?-    -.v
        %del  res                                      ::  no longer exists
        %ins                                           ::  new file
      %+  ~(put by res)  pat 
      %+  make-direct  p.v  %c                         ::  TODO content type?
        %mut                                           ::  patch from r
      %+  ~(put by res)  pat
      %-  make-direct
      :_  %c
      %+  lump  p.v
      %-  lobe-to-noun
      %-  ~(got by q.r)  pat
    ==
  ::
  ::  merge types
  ::
```

XX document

###++mate

```
  ++  mate                                          ::  merge p,q
    |=  con=?                                       ::  %mate, %meld
    |=  [p=yaki q=yaki us=[ship desk] th=[ship desk]]
    ^-  (map path blob)
    =+  r=(~(tap in (find-merge-points p q)) ~)
    ?~  r
      ~|(%mate-no-ancestor !!)
    ?:  =(1 (lent r))
      (meld p q i.r con us th)
    ~|(%mate-criss-cross !!)
  ::
```

XX document

###++keep

```
  ++  keep                                          ::  %this
    |=  [p=yaki q=yaki [ship desk] [ship desk]]
    ^-  (map path blob)
    %+  roll  (~(tap by q.p) ~)
    |=  [[pat=path lob=lobe] zar=(map path blob)]
    ^-  (map path blob)
    (~(put by zar) pat (lobe-to-blob lob))
  ::
```

XX document

###++drop

```
  ++  drop                                          ::  %that
    |=  [p=yaki q=yaki r=[ship desk] s=[ship desk]]
    ^-  (map path blob)
    (keep q p r s)
  ::
```

XX document

###++forge

```
  ++  forge                                         ::  %forge
    |=  [p=yaki q=yaki s=[ship desk] t=[ship desk]]
    ^-  (map path blob)
    =+  r=(~(tap in (find-merge-points p q)) ~)
    ?~  r
      ~|(%forge-no-ancestor !!)
    %-  |=  [r=yaki lut=(map lobe blob) hat=(map tako yaki)]
        =.  lat  lut
        =.  hut  hat
        (meld p q r & s t)                          ::  fake merge
    %+  roll  t.r                                   ::  fake ancestor
    |=  [par=yaki [for=_i.r lut=_lat hat=_hut]]
    =.  lat  lut
    =+  ^=  far
        ^-  (map path lobe)
        %-  ~(tur by (forge par for s t))
        |=  [k=path v=blob]  (blob-to-lobe v)
    =+  u=(make-yaki [r.par r.for ~] far `@da`0)    ::  fake yaki
    :-  u
    :_  (~(put by hat) r.u u)
    =<  -
    %-  update-lat
    :_  ~
    %-  ~(tur by q.u)
    |=  [path k=lobe]
    (lobe-to-blob k)
  ::
  ::  actual merge
  ::
```

XX document

###++merge

```
  ++  merge
    |=  [us=[ship desk] th=[ship desk]]
    |=  [p=yaki q=yaki r=@da s=$+([yaki yaki [ship desk] [ship desk]] (map path blob))]
    ^-  [yaki (map path blob)]
    =+  u=(s p q us th)
    =+  ^=  t
        ^-  (map path lobe)
        %+  roll  (~(tap by u) ~)
        |=  [[pat=path bar=blob] yeb=(map path lobe)]
        (~(put by yeb) pat (blob-to-lobe bar))
    :_  u
    (make-yaki [r.p r.q ~] t r)
  ::
```

XX document

###++strategy

```
  ++  strategy                                          ::  merge strategy
    |=  gem=?(%meld %mate %that %this)
    ?-  gem
      %meld  (mate %.y)
      %mate  (mate %.n)
      %this  keep
      %that  drop
    ==
  ::
```

XX document

###++construct

``````

XX document

###++read

```
  ++  read                                              ::    read:ze
    |=  mun=mood                                        ::  read at point
    ^-  (unit)
    ?:  ?=(%v p.mun)
      [~ `dome`+<+<.read]
    ?:  &(?=(%w p.mun) !?=(%ud -.q.mun))
      ?^(r.mun ~ [~ let])
    ?:  ?=(%w p.mun)
      =+  ^=  yak
          %-  aeon-to-yaki
          let
      ?^(r.mun ~ [~ [t.yak (forge-nori yak)]])
      ::?>  ?=(^ hit)  ?^(r.mun ~ [~ i.hit])     ::  what do?? need [@da nori]
    (query(ank ank:(descend-path:(zu ank) r.mun)) p.mun)
  ::
```

XX document

###++read

```
  ++  read                                              ::    read:ze
    |=  mun=mood                                        ::  read at point
    ^-  (unit)
    ?:  ?=(%v p.mun)
      [~ `dome`+<+<.read]
    ?:  &(?=(%w p.mun) !?=(%ud -.q.mun))
      ?^(r.mun ~ [~ let])
    ?:  ?=(%w p.mun)
      =+  ^=  yak
          %-  aeon-to-yaki
          let
      ?^(r.mun ~ [~ [t.yak (forge-nori yak)]])
      ::?>  ?=(^ hit)  ?^(r.mun ~ [~ i.hit])     ::  what do?? need [@da nori]
    (query(ank ank:(descend-path:(zu ank) r.mun)) p.mun)
  ::
```

XX document

###++equiv

```
  ++  equiv                                             ::  test paths
    |=  [p=(map path lobe) q=(map path lobe)]
    ^-  ?
    =-  ?.  qat  %.n
        %+  levy  (~(tap by q) ~)
        |=  [pat=path lob=lobe]
        (~(has by p) pat)
    ^=  qat
    %+  levy  (~(tap by p) ~)
    |=  [pat=path lob=lobe]
    =+  zat=(~(get by q) pat)
    ?~  zat  %.n
    =((lobe-to-noun u.zat) (lobe-to-noun lob))
  ::
```

XX document

###++edit

```
  ++  edit                                              ::    edit:ze
    |=  [wen=@da lem=nori]                              ::  edit
    ^+  +>
    ?-  -.lem
      &  =^  yak  lat                                   ::  merge objects
             %+  forge-yaki  wen
             ?:  =(let 0)                               ::  initial import
               [~ q.lem]
             [(some r:(aeon-to-yaki let)) q.lem]
         ?.  ?|  =(0 let)
                 !=((lent p.yak) 1)
                 !(equiv q.yak q:(aeon-to-yaki let))
             ==
           +>.$                                         ::  silently ignore
         =:  let  +(let)
             hit  (~(put by hit) +(let) r.yak)
             hut  (~(put by hut) r.yak yak)
         ==
         +>.$(ank (checkout-ankh q.yak))
      |  +>.$(lab ?<((~(has by lab) p.lem) (~(put by lab) p.lem let)))
    ==
::
```

XX document

###++zu

```
++  zu                                                  ::  filesystem
  |=  ank=ankh                                          ::  filesystem state
  =|  myz=(list ,[p=path q=miso])                       ::  changes in reverse
  =|  ram=path                                          ::  reverse path into
  |%
```

XX document

###++rehash

```
  ++  rehash                                            ::  local rehash
    ^-  cash
    %+  mix  ?~(q.ank 0 p.u.q.ank)
    =+  axe=1
    |-  ^-  cash
    ?~  r.ank  _@
    ;:  mix
      (shaf %dash (mix axe (shaf %dush (mix p.n.r.ank p.q.n.r.ank))))
      $(r.ank l.r.ank, axe (peg axe 2))
      $(r.ank r.r.ank, axe (peg axe 3))
    ==
  ::
```

XX document

###++update

``````

XX document

###++ascend

```
  ++  ascend                                            ::  ascend
    |=  [lol=@ta kan=ankh]
    ^+  +>
    ?>  &(?=(^ ram) =(lol i.ram))
    %=    +>
        ram  t.ram
        ank
      ?:  =([0 ~ ~] ank)
        ?.  (~(has by r.kan) lol)  kan
        kan(r (~(del by r.kan) lol))
      kan(r (~(put by r.kan) lol ank))
    ==
  ::
```

XX document

###++push

``````

XX document

###++descend

```
  ++  descend                                           ::  descend
    |=  lol=@ta
    ^+  +>
    =+  you=(~(get by r.ank) lol)
    +>.$(ram [lol ram], ank ?~(you [*cash ~ ~] u.you))
  ::
```

XX document

###++descend

```
  ++  descend                                           ::  descend
    |=  lol=@ta
    ^+  +>
    =+  you=(~(get by r.ank) lol)
    +>.$(ram [lol ram], ank ?~(you [*cash ~ ~] u.you))
  ::
```

XX document

###++overwrite

```
  ++  overwrite                                         ::  write over
    |=  [pum=umph val=(unit ,[p=cash q=*])]
    ^+  +>
    ?~  q.ank
      ?~  val  +>
      (push-change %ins q.u.val)
    ?~  val
      (push-change %del q.u.q.ank)
    ?:  =(q.u.val q.u.q.ank)  +>
    (push-change %mut ((diff pum) q.u.q.ank q.u.val))
  ::
```

XX document

###++change

``````

XX document

###++rm

``````

XX document

###++drum

```
  ++  drum                                              ::  apply effect
    |=  [pax=path mis=miso]                             ::  XX unused (++dune)
    ^+  +>
    ?^  pax
      update-hash:(ascend:$(pax t.pax, +> (descend i.pax)) i.pax ank)
    ~|  %clay-fail
    ?-    -.mis
        %del
      ?>  &(?=(^ q.ank) =(q.u.q.ank p.mis))
      +>.$(p.ank (mix p.u.q.ank p.ank), q.ank ~)
    ::
        %ins
      ?>  ?=(~ q.ank)
      =+  sam=(sham p.mis)
      +>.$(p.ank (mix sam p.ank), q.ank [~ sam p.mis])
    ::
        %mut
      ?>  ?=(^ q.ank)
      =+  nex=(lump p.mis q.u.q.ank)
      =+  sam=(sham nex)
      +>.$(p.ank :(mix sam p.u.q.ank p.ank), q.ank [~ sam nex])
    ==
  ::
```

XX document

    |=  [pax=path mis=miso]                             ::  XX unused (++dune)

###++dune

```
  ++  dune                                              ::  apply
    |-  ^+  +                                           ::  XX unused (++durn)
    ?~  myz  +
    =>  .(+ (drum p.i.myz q.i.myz))
    $(myz ?>(?=(^ myz) t.myz))
  ::
```

XX document

    |-  ^+  +                                           ::  XX unused (++durn)

###++durn

```
  ++  durn                                              ::  apply forward
    |=  nyp=soba                                        ::  XX unused
    ^+  +>
    ?:  =([0 0] p.nyp)
      dune(myz q.nyp)
    =>  ?:  =(p.ank p.p.nyp)  .
        ~&  [%durn-in-wrong p.ank p.p.nyp]
        .
    =.  +>  dune(myz q.nyp)
    =>  ?:  =(p.ank q.p.nyp)  .
        ~&  [%durn-out-wrong p.ank q.p.nyp]
        .
    +>
```

XX document

##section 3bF, names etc

###++clan

```
++  clan                                                ::  ship to rank
  |=  who=ship  ^-  rank
  =+  wid=(met 3 who)
  ?:  (lte wid 1)   %czar
  ?:  =(2 wid)      %king
  ?:  (lte wid 4)   %duke
  ?:  (lte wid 8)   %earl
  ?>  (lte wid 16)  %pawn
::
```

XX document

###++deft

```
++  deft                                                ::  import url path
  |=  rax=(list ,@t)
  |-  ^-  pork
  ?~  rax
    [~ ~]
  ?~  t.rax
    =+  den=(trip i.rax)
    =+  ^=  vex
      %-  %-  full
          ;~(plug sym ;~(pose (stag ~ ;~(pfix dot sym)) (easy ~)))
      [[1 1] (trip i.rax)]
    ?~  q.vex
      [~ [i.rax ~]]
    [+.p.u.q.vex [-.p.u.q.vex ~]]
  =+  pok=$(rax t.rax)
  :-  p.pok
  [i.rax q.pok]
::
```

XX document

###++fain

```
++  fain                                                ::  path restructure
  |=  [hom=path raw=path]
  =+  bem=(need (tome raw))
  =+  [mer=(flop s.bem) moh=(flop hom)]
  |-  ^-  (pair beam path)
  ?~  moh  
    [bem(s hom) (flop mer)]
  ?>  &(?=(^ mer) =(i.mer i.moh))
  $(mer t.mer, moh t.moh)
::
```

XX document

###++fest

```
++  fest                                                ::  web synthesizer
  |=  [hom=path raw=path]
  |*  yax=$+(epic *)
  (yax (fuel (fain hom raw)))
::
```

XX document

###++folk

```
++  folk                                                ::  silk construction
  |=  [hom=path raw=path]
  |*  yox=$+((pair beam path) *)
  (yox (fain hom raw))
::
```

XX document

###++fuel

```
++  fuel                                                ::  parse fcgi
  |=  [bem=beam but=path]
  ^-  epic
  ?>  ?=([%web @ *] but)
  =+  dyb=(slay i.t.but)
  ?>  ?&  ?=([~ %many *] dyb)
          ?=([* * *] p.u.dyb)
          ::  ?=([%$ %tas *] i.p.u.dyb)
          ?=([%many *] i.p.u.dyb)
          ?=([%blob *] i.t.p.u.dyb)
      ==
  =+  ced=((hard cred) p.i.t.p.u.dyb)
  ::  =+  nep=q.p.i.p.u.dyb
  =+  ^=  nyp  ^-  path
      %+  turn  p.i.p.u.dyb
      |=  a=coin  ^-  @ta
      ?>  ?=([%$ %ta @] a)
      ?>(((sane %ta) q.p.a) q.p.a)
  =+  ^=  gut  ^-  (list ,@t)
      %+  turn  t.t.p.u.dyb
      |=  a=coin  ^-  @t
      ?>  ?=([%$ %t @] a)
      ?>(((sane %t) q.p.a) q.p.a)
  =+  ^=  quy
      |-  ^-  (list ,[p=@t q=@t])
      ?~  gut  ~
      ?>  ?=(^ t.gut)
      [[i.gut i.t.gut] $(gut t.t.gut)]
  :*  (~(gas by *(map cord cord)) quy)
      ced
      bem
      t.t.but
      nyp
  ==

::
```

XX document

###++gist

```
++  gist                                                ::  convenient html
  |=  [hom=path raw=path]
  |=  yax=$+(epic marl)
  %-  (fest hom raw)
  |=  piq=epic
  ^-  manx
  =+  ^=  sip                                           ::  skip blanks
      |=  mal=marl
      ?~(mal ~ ?.(|(=(:/(~) i.mal) =(:/([10 ~]) i.mal)) mal $(mal t.mal)))
  =+  zay=`marl`(yax piq)
  =.  zay  (sip zay)
  =+  ^=  twa
      |-  ^-  [p=marl q=marl]
      ?~  zay  [~ ~]
      ?:  ?=([[[%head *] *] *] zay)
        [c.i.zay ?:(?=([[[%body *] *] ~] t.zay) c.i.t.zay t.zay)]
      ?:  ?=([[[%title *] *] *] zay)
        [[i.zay ~] t.zay]
      [~ zay]
  [/html [/head (sip p.twa)] [/body (sip q.twa)] ~]
::
```

XX document

###++urle

```
++  urle                                                ::  URL encode
  |=  tep=tape
  ^-  tape
  %-  zing
  %+  turn  tep
  |=  tap=char
  =+  xen=|=(tig=@ ?:((gte tig 10) (add tig 55) (add tig '0')))
  ?:  ?|  &((gte tap 'a') (lte tap 'z'))
          &((gte tap 'A') (lte tap 'Z'))
          &((gte tap '0') (lte tap '9'))
          =('.' tap)
          =('-' tap)
          =('~' tap)
          =('_' tap)
      ==
    [tap ~]
  ['%' (xen (rsh 0 4 tap)) (xen (end 0 4 tap)) ~]
::
```

XX document

###++urld

```
++  urld                                                ::  URL decode
  |=  tep=tape
  ^-  (unit tape)
  ?~  tep  [~ ~]
  ?:  =('%' i.tep)
    ?.  ?=([@ @ *] t.tep)  ~
    =+  nag=(mix i.t.tep (lsh 3 1 i.t.t.tep))
    =+  val=(rush nag hex:ag)
    ?~  val  ~
    =+  nex=$(tep t.t.t.tep)
    ?~(nex ~ [~ [`@`u.val u.nex]])
  =+  nex=$(tep t.tep)
  ?~(nex ~ [~ i.tep u.nex])
```

XX document

###++sifo

```
++  sifo                                                ::  64-bit encode
  |=  tig=@
  ^-  tape
  =+  poc=(mod (sub 3 (mod (met 3 tig) 3)) 3)
  =+  pad=(lsh 3 poc (swap 3 tig))
  =+  ^=  ska
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  =+  ^=  sif
      %-  flop
      |-  ^-  tape
      ?~  pad
        ~
      =+  d=(end 0 6 pad)
      [(snag d ska) $(pad (rsh 0 6 pad))]
  (weld (scag (sub (lent sif) poc) sif) (trip (fil 3 poc '=')))
::
```

XX document

###++earl

```
++  earl                                                ::  local purl to tape
  |=  [who=@p pul=purl]
  ^-  purl
  pul(q.q [(rsh 3 1 (scot %p who)) q.q.pul])
::
```

XX document

###++earn

```
++  earn                                                ::  purl to tape
  |=  pul=purl
  ^-  tape
  =<  apex
  |%
```

XX document

###++apex

```
  ++  apex
    ^-  tape
    :(weld head "/" body tail)
  ::
```

XX document

###++body

```
  ++  body
    |-  ^-  tape
    ?~  q.q.pul
      ?~(p.q.pul ~ ['.' (trip u.p.q.pul)])
    =+  seg=(trip i.q.q.pul)
    ?:(=(~ t.q.q.pul) seg (weld seg `tape`['/' $(q.q.pul t.q.q.pul)]))
  ::
```

XX document

###++head

```
  ++  head
    ^-  tape
    ;:  weld
      ?:(&(p.p.pul !=([& /localhost] r.p.pul)) "https://" "http://")
    ::
      ?-  -.r.p.pul
        |  (trip (rsh 3 1 (scot %if p.r.p.pul)))
        &  =+  rit=(flop p.r.p.pul)
           |-  ^-  tape
           ?~(rit ~ (weld (trip i.rit) ?~(t.rit "" `tape`['.' $(rit t.rit)])))
      ==
    ::
      ?~(q.p.pul ~ `tape`[':' (trip (rsh 3 2 (scot %ui u.q.p.pul)))])
    ==
  ::
```

XX document

###++tail

```
  ++  tail
    ^-  tape
    ?:  =(~ r.pul)  ~
    :-  '?'
    |-  ^-  tape
    ?~  r.pul  ~
    ;:  weld
      (trip p.i.r.pul)
      "="
      (trip q.i.r.pul)
      ?~(t.r.pul ~ `tape`['&' $(r.pul t.r.pul)])
    ==
::
```

XX document

###++epur

```
++  epur                                                ::  url/header parser
  |%
```

XX document

###++apat

```
  ++  apat                                              ::  2396 abs_path
    %+  cook  deft
    (ifix [fas ;~(pose fas (easy ~))] (more fas smeg))
```

XX document

###++auri

```
  ++  auri
    %+  cook
      |=  a=purl
      ?.(=([& /localhost] r.p.a) a a(p.p &))
    ;~  plug
      ;~  plug
        %+  sear
          |=  a=@t
          ^-  (unit ,?)
          ?+(a ~ %http [~ %|], %https [~ %&])
        ;~(sfix scem ;~(plug col fas fas))
        thor
      ==
      ;~(plug ;~(pose apat (easy *pork)) yque)
    ==
```

XX document

###++cock

```
  ++  cock                                              ::  cookie
    (most ;~(plug sem ace) ;~(plug toke ;~(pfix tis tosk)))
```

XX document

###++dlab

```
  ++  dlab                                              ::  2396 domainlabel
    %+  sear
      |=  a=@ta
      ?.(=('-' (rsh 3 a (dec (met 3 a)))) [~ u=a] ~)
    %+  cook  cass
    ;~(plug aln (star alp))
  ::
```

XX document

###++fque

```
  ++  fque  (cook crip (plus pquo))                     ::  normal query field
```

XX document

###++fquu

```
  ++  fquu  (cook crip (star pquo))                     ::  optional field
```

XX document

###++pcar

```
  ++  pcar  ;~(pose pure pesc psub col pat)             ::  2396 path char
```

XX document

###++pcok

```
  ++  pcok  ;~  pose                                    ::  cookie char
              (just `@`0x21)
              (shim 0x23 0x2b)
              (shim 0x2d 0x3a)
              (shim 0x3c 0x5b)
              (shim 0x5d 0x7e)
            ==
```

XX document

###++pesc

```
  ++  pesc  ;~(pfix cen mes)                            ::  2396 escaped
```

XX document

###++pold

```
  ++  pold  (cold ' ' (just '+'))                       ::  old space code
```

XX document

###++pque

```
  ++  pque  ;~(pose pcar fas wut)                       ::  3986 query char
```

XX document

###++pquo

```
  ++  pquo  ;~(pose pure pesc pold)                     ::  normal query char
```

XX document

###++pure

```
  ++  pure  ;~(pose aln hep dot cab sig)                ::  2396 unreserved
```

XX document

###++psub

```
  ++  psub  ;~  pose                                    ::  3986 sub-delims
              zap  buc  pam  soq  pel  per
              tar  lus  com  sem  tis
            ==
```

XX document

###++ptok

```
  ++  ptok  ;~  pose                                    ::  2616 token
              aln  zap  hax  buc  cen  pam  soq  tar  lus
              hep  dot  ket  cab  tec  bar  sig
            ==
```

XX document

###++scem

```
  ++  scem                                              ::  2396 scheme
    %+  cook  cass
    ;~(plug alf (star ;~(pose aln lus hep dot)))
  ::
```

XX document

###++smeg

```
  ++  smeg  (cook crip (plus pcar))                     ::  2396 segment
```

XX document

###++tock

```
  ++  tock  (cook crip (plus pcok))                     ::  6265 cookie-value
```

XX document

###++tosk

```
  ++  tosk  ;~(pose tock (ifix [doq doq] tock))         ::  6265 cookie-value
```

XX document

###++toke

```
  ++  toke  (cook crip (plus ptok))                     ::  2616 token
```

XX document

###++thor

```
  ++  thor                                              ::  2396 host/port
    %+  cook  |*(a=[* *] [+.a -.a])
    ;~  plug
      thos
      ;~(pose (stag ~ ;~(pfix col dim:ag)) (easy ~))
    ==
```

XX document

###++thos

```
  ++  thos                                              ::  2396 host, no local
    ;~  plug
      ;~  pose
        %+  stag  %&
        %+  sear                                        ::  LL parser weak here
          |=  a=(list ,@t)
          =+  b=(flop a)
          ?>  ?=(^ b)
          =+  c=(end 3 1 i.b)
          ?.(&((gte c 'a') (lte c 'z')) ~ [~ u=b])
        (most dot dlab)
      ::
        %+  stag  %|
        =+  tod=(ape:ag ted:ab)
        %+  bass  256
        ;~(plug tod (stun [3 3] ;~(pfix dot tod)))
      ==
    ==
```

XX document

###++yque

```
  ++  yque                                              ::  query ending
    ;~  pose
      ;~(pfix wut yquy)
      (easy ~)
    ==
```

XX document

###++yquy

```
  ++  yquy                                              ::  query
    ;~  pose                                            ::  proper query
      %+  more
        ;~(pose pam sem)
      ;~(plug fque ;~(pose ;~(pfix tis fquu) (easy '')))
    ::
      %+  cook                                          ::  funky query
        |=(a=tape [[%$ (crip a)] ~])
      (star pque)
    ==
```

XX document

###++zest

```
  ++  zest                                              ::  2616 request-uri
    ;~  pose
      (stag %& (cook |=(a=purl a) auri))
      (stag %| ;~(plug apat yque))
    ==
::
```

XX document

###++feel

```
++  feel                                                ::  simple file write
  |=  [pax=path val=*]
  ^-  miso
  =+  dir=((hard arch) .^(%cy pax))
  ?~  q.dir  [%ins val]
  :-  %mut
  ^-  udon
  [%a %a .^(%cx pax) val]
::
```

XX document

###++file

```
++  file                                                ::  simple file load
  |=  pax=path
  ^-  (unit)
  =+  dir=((hard arch) .^(%cy pax))
  ?~(q.dir ~ [~ .^(%cx pax)])
::
```

XX document

###++foal

```
++  foal                                                ::  high-level write
  |=  [pax=path val=*]
  ^-  toro
  ?>  ?=([* * * *] pax)
  [i.t.pax [%& [*cart [[t.t.t.pax (feel pax val)] ~]]]]
::
```

XX document

###++fray

```
++  fray                                                ::  high-level delete
  |=  pax=path
  ^-  toro
  ?>  ?=([* * * *] pax)
  [i.t.pax [%& [*cart [[t.t.t.pax [%del .^(%cx pax)]] ~]]]]
::
```

XX document

###++furl

```
++  furl                                                ::  unify changes
  |=  [one=toro two=toro] 
  ^-  toro
  ~|  %furl
  ?>  ?&  =(p.one p.two)                                ::  same path
          &(?=(& -.q.one) ?=(& -.q.two))                ::  both deltas
      ==
  [p.one [%& [*cart (weld q.q.q.one q.q.q.two)]]]
::
```

XX document

###++glam

```
++  glam
  |=  zar=@p  ^-  tape
  %+  snag  zar
  ^-  (list tape)
  :~  "Tianming"  "Pepin the Short"  "Haile Selassie"  "Alfred the Great"
      "Tamerlane"  "Pericles"  "Talleyrand"  "Yongle"  "Seleucus"
      "Uther Pendragon"  "Louis XVI"  "Ahmad Shh Durrn"  "Constantine"
      "Wilhelm I"  "Akbar"  "Louis XIV"  "Nobunaga"  "Alexander VI"
      "Philippe II"  "Julius II"  "David"  "Niall Nogallach"  "Kublai Khan"
      "z Beg Khan"  "Ozymandias"  "gedei Khan"  "Jiang Jieshi"  "Darius"
      "Shivaji"  "Qianlong"  "Bolesaw I Chrobry"  "Tigranes"  "Han Wudi"
      "Charles X"  "Naresuan"  "Frederick II"  "Simeon"  "Kangxi"
      "Suleiman the Magnificent"  "Pedro II"  "Genghis Khan"  "Laozi"
      "Porfirio Daz"  "Pakal"  "Wu Zetian"  "Garibaldi"  "Matthias Corvinus"
      "Leopold II"  "Leonidas"  "Sitting Bull"  "Nebuchadnezzar II"
      "Rhodes"  "Henry VIII"  "Attila"  "Catherine II"  "Chulalongkorn"
      "Uthmn"  "Augustus"  "Faustin"  "Chongde"  "Justinian"
      "Afonso de Albuquerque"  "Antoninus Pius"  "Cromwell"  "Innocent X"
      "Fidel"  "Frederick the Great"  "Canute"  "Vytautas"  "Amina"
      "Hammurabi"  "Suharto"  "Victoria"  "Hiawatha"  "Paul V"  "Shaka"
      "L Thnh Tng"  "Ivan Asen II"  "Tiridates"  "Nefertiti"  "Gwangmu"
      "Ferdinand & Isabella"  "Askia"  "Xuande"  "Boris Godunov"  "Gilgamesh"
      "Maximillian I"  "Mao"  "Charlemagne"  "Narai"  "Hanno"  "Charles I & V"
      "Alexander II"  "Mansa Musa"  "Zoe Porphyrogenita"  "Metternich"
      "Robert the Bruce"  "Pachacutec"  "Jefferson"  "Solomon"  "Nicholas I"
      "Barbarossa"  "FDR"  "Pius X"  "Gwanggaeto"  "Abbas I"  "Julius Caesar"
      "Lee Kuan Yew"  "Ranavalona I"  "Go-Daigo"  "Zenobia"  "Henry V"
      "Bo i"  "Casimir III"  "Cyrus"  "Charles the Wise"  "Sandrokottos"
      "Agamemnon"  "Clement VII"  "Suppiluliuma"  "Deng Xiaoping"
      "Victor Emmanuel"  "Ajatasatru"  "Jan Sobieski"  "Huangdi"  "Xuantong"
      "Narmer"  "Cosimo de' Medici"  "Mngke Khan"  "Stephen Duan"  "Henri IV"
      "Mehmed Fatih"  "Conn Ctchathach"  "Francisco Franco"  "Leo X"
      "Kammu"  "Krishnadevaraya"  "Elizabeth I"  "Norton I"  "Washington"
      "Meiji"  "Umar"  "TR"  "Peter the Great"  "Agustin I"  "Ashoka"
      "William the Conqueror"  "Kongolo Mwamba"  "Song Taizu"
      "Ivan the Terrible"  "Yao"  "Vercingetorix"  "Geronimo"  "Rurik"
      "Urban VIII"  "Alexios Komnenos"  "Maria I"  "Tamar"  "Bismarck"
      "Arthur"  "Jimmu"  "Gustavus Adolphus"  "Suiko"  "Basil I"  "Montezuma"
      "Santa Anna"  "Xerxes"  "Beyazt Yldrm"  "Samudragupta"  "James I"
      "George III"  "Kamehameha"  "Francesco Sforza"  "Trajan"
      "Rajendra Chola"  "Hideyoshi"  "Cleopatra"  "Alexander"
      "Ashurbanipal"  "Paul III"  "Vespasian"  "Tecumseh"  "Narasimhavarman"
      "Suryavarman II"  "Bokassa I"  "Charles Canning"  "Theodosius"
      "Francis II"  "Zhou Wen"  "William Jardine"  "Ahmad al-Mansur"
      "Lajos Nagy"  "Theodora"  "Mussolini"  "Samuil"  "Osman Gazi"
      "Kim Il-sung"  "Maria Theresa"  "Lenin"  "Tokugawa"  "Marcus Aurelius"
      "Nzinga Mbande"  "Edward III"  "Joseph II"  "Pulakesi II"  "Priam"
      "Qin Shi Huang"  "Shah Jahan"  "Sejong"  "Sui Wendi"  "Otto I"
      "Napoleon III"  "Prester John"  "Dido"  "Joao I"  "Gregory I"
      "Gajah Mada"  "Abd-ar Rahmn III"  "Taizong"  "Franz Josef I"
      "Nicholas II"  "Gandhi"  "Chandragupta II"  "Peter III"
      "Oba Ewuare"  "Louis IX"  "Napoleon"  "Selim Yavuz"  "Shun"
      "Hayam Wuruk"  "Jagieo"  "Nicaule"  "Sargon"  "Saladin"  "Charles II"
      "Brian Boru"  "Da Yu"  "Antiochus III"  "Charles I"
      "Jan Pieterszoon Coen"  "Hongwu"  "Mithridates"  "Hadrian"  "Ptolemy"
      "Benito Juarez"  "Sun Yat-sen"  "Raja Raja Chola"  "Bolivar"  "Pius VII"
      "Shapur II"  "Taksin"  "Ram Khamhaeng"  "Hatshepsut"  "Al"  "Matilda"
      "Ataturk"
  ==
::
```

XX document

###++glon

```
++  glon
  |=  lag=lang
  ^-  (unit tape)
  ?+  lag  ~
    %aa  [~ "Afar"]
    %ab  [~ "Abkhazian"]
    %ae  [~ "Avestan"]
    %af  [~ "Afrikaans"]
    %ak  [~ "Akan"]
    %am  [~ "Amharic"]
    %an  [~ "Aragonese"]
    %ar  [~ "Arabic"]
    %as  [~ "Assamese"]
    %av  [~ "Avaric"]
    %ay  [~ "Aymara"]
    %az  [~ "Azerbaijani"]
    %ba  [~ "Bashkir"]
    %be  [~ "Belarusian"]
    %bg  [~ "Bulgarian"]
    %bh  [~ "Bihari"]
    %bi  [~ "Bislama"]
    %bm  [~ "Bambara"]
    %bn  [~ "Bengali"]
    %bo  [~ "Tibetan"]
    %br  [~ "Breton"]
    %bs  [~ "Bosnian"]
    %ca  [~ "Catalan"]
    %ce  [~ "Chechen"]
    %ch  [~ "Chamorro"]
    %co  [~ "Corsican"]
    %cr  [~ "Cree"]
    %cs  [~ "Czech"]
    %cu  [~ "Slavonic"]
    %cv  [~ "Chuvash"]
    %cy  [~ "Welsh"]
    %da  [~ "Danish"]
    %de  [~ "German"]
    %dv  [~ "Maldivian"]
    %dz  [~ "Dzongkha"]
    %ee  [~ "Ewe"]
    %el  [~ "Greek"]
    %en  [~ "English"]
    %eo  [~ "Esperanto"]
    %es  [~ "Spanish"]
    %et  [~ "Estonian"]
    %eu  [~ "Basque"]
    %fa  [~ "Persian"]
    %ff  [~ "Fulah"]
    %fi  [~ "Finnish"]
    %fj  [~ "Fijian"]
    %fo  [~ "Faroese"]
    %fr  [~ "French"]
    %fy  [~ "Frisian"]
    %ga  [~ "Irish Gaelic"]
    %gd  [~ "Scottish Gaelic"]
    %gl  [~ "Galician"]
    %gn  [~ "Guarani"]
    %gu  [~ "Gujarati"]
    %gv  [~ "Manx"]
    %ha  [~ "Hausa"]
    %he  [~ "Hebrew"]
    %hi  [~ "Hindi"]
    %ho  [~ "Hiri Motu"]
    %hr  [~ "Croatian"]
    %ht  [~ "Haitian Creole"]
    %hu  [~ "Hungarian"]
    %hy  [~ "Armenian"]
    %hz  [~ "Herero"]
    %ia  [~ "Interlingua"]
    %id  [~ "Indonesian"]
    %ie  [~ "Occidental"]
    %ig  [~ "Igbo"]
    %ii  [~ "Nuosu"]
    %ik  [~ "Inupiaq"]
    %io  [~ "Ido"]
    %is  [~ "Icelandic"]
    %it  [~ "Italian"]
    %iu  [~ "Inuktitut"]
    %ja  [~ "Japanese"]
    %jv  [~ "Javanese"]
    %ka  [~ "Georgian"]
    %kg  [~ "Kongo"]
    %ki  [~ "Kikuyu"]
    %kj  [~ "Kwanyama"]
    %kk  [~ "Kazakh"]
    %kl  [~ "Kalaallisut"]
    %km  [~ "Central Khmer"]
    %kn  [~ "Kannada"]
    %ko  [~ "Korean"]
    %kr  [~ "Kanuri"]
    %ks  [~ "Kashmiri"]
    %ku  [~ "Kurdish"]
    %kv  [~ "Komi"]
    %kw  [~ "Cornish"]
    %ky  [~ "Kyrgyz"]
    %la  [~ "Latin"]
    %lb  [~ "Luxembourgish"]
    %lg  [~ "Ganda"]
    %li  [~ "Limburgish"]
    %ln  [~ "Lingala"]
    %lo  [~ "Lao"]
    %lt  [~ "Lithuanian"]
    %lu  [~ "Luba-Katanga"]
    %lv  [~ "Latvian"]
    %mg  [~ "Malagasy"]
    %mh  [~ "Marshallese"]
    %mi  [~ "Maori"]
    %mk  [~ "Macedonian"]
    %ml  [~ "Malayalam"]
    %mn  [~ "Mongolian"]
    %mr  [~ "Marathi"]
    %ms  [~ "Malay"]
    %mt  [~ "Maltese"]
    %my  [~ "Burmese"]
    %na  [~ "Nauru"]
    %nb  [~ "Norwegian Bokml"]
    %nd  [~ "North Ndebele"]
    %ne  [~ "Nepali"]
    %ng  [~ "Ndonga"]
    %nl  [~ "Dutch"]
    %nn  [~ "Norwegian Nynorsk"]
    %no  [~ "Norwegian"]
    %nr  [~ "South Ndebele"]
    %nv  [~ "Navajo"]
    %ny  [~ "Chichewa"]
    %oc  [~ "Occitan"]
    %oj  [~ "Ojibwa"]
    %om  [~ "Oromo"]
    %or  [~ "Oriya"]
    %os  [~ "Ossetian"]
    %pa  [~ "Punjabi"]
    %pi  [~ "Pali"]
    %pl  [~ "Polish"]
    %ps  [~ "Pashto"]
    %pt  [~ "Portuguese"]
    %qu  [~ "Quechua"]
    %rm  [~ "Romansh"]
    %rn  [~ "Rundi"]
    %ro  [~ "Romanian"]
    %ru  [~ "Russian"]
    %rw  [~ "Kinyarwanda"]
    %sa  [~ "Sanskrit"]
    %sc  [~ "Sardinian"]
    %sd  [~ "Sindhi"]
    %se  [~ "Northern Sami"]
    %sg  [~ "Sango"]
    %si  [~ "Sinhala"]
    %sk  [~ "Slovak"]
    %sl  [~ "Slovenian"]
    %sm  [~ "Samoan"]
    %sn  [~ "Shona"]
    %so  [~ "Somali"]
    %sq  [~ "Albanian"]
    %sr  [~ "Serbian"]
    %ss  [~ "Swati"]
    %st  [~ "Sotho"]
    %su  [~ "Sundanese"]
    %sv  [~ "Swedish"]
    %sw  [~ "Swahili"]
    %ta  [~ "Tamil"]
    %te  [~ "Telugu"]
    %tg  [~ "Tajik"]
    %th  [~ "Thai"]
    %ti  [~ "Tigrinya"]
    %tk  [~ "Turkmen"]
    %tl  [~ "Tagalog"]
    %tn  [~ "Tswana"]
    %to  [~ "Tonga"]
    %tr  [~ "Turkish"]
    %ts  [~ "Tsonga"]
    %tt  [~ "Tatar"]
    %tw  [~ "Twi"]
    %ty  [~ "Tahitian"]
    %ug  [~ "Uighur"]
    %uk  [~ "Ukrainian"]
    %ur  [~ "Urdu"]
    %uz  [~ "Uzbek"]
    %ve  [~ "Venda"]
    %vi  [~ "Vietnamese"]
    %vo  [~ "Volapk"]
    %wa  [~ "Walloon"]
    %wo  [~ "Wolof"]
    %xh  [~ "Xhosa"]
    %yi  [~ "Yiddish"]
    %yo  [~ "Yoruba"]
    %za  [~ "Zhuang"]
    %zh  [~ "Chinese"]
    %zu  [~ "Zulu"]
  ==
::
```

XX document

###++gnow

```
++  gnow
  |=  [who=@p gos=gcos]  ^-  @t
  ?-    -.gos
      %czar                 (rap 3 '|' (rap 3 (glam who)) '|' ~)
      %king                 (rap 3 '_' p.gos '_' ~)
      %earl                 (rap 3 ':' p.gos ':' ~)
      %pawn                 ?~(p.gos %$ (rap 3 '.' u.p.gos '.' ~))
      %duke
    ?:  ?=(%anon -.p.gos)  %$
    %+  rap  3
    ^-  (list ,@)
    ?-    -.p.gos
        %punk  ~['"' q.p.gos '"']
        ?(%lord %lady)
      =+  ^=  nad
          =+  nam=`name`s.p.p.gos
          %+  rap  3
          :~  p.nam
              ?~(q.nam 0 (cat 3 ' ' u.q.nam))
              ?~(r.nam 0 (rap 3 ' (' u.r.nam ')' ~))
              ' '
              s.nam
          ==
      ?:(=(%lord -.p.gos) ~['[' nad ']'] ~['(' nad ')'])
    ==
  ==
::
```

XX document

###++hunt

```
++  hunt                                                ::  first of unit dates
  |=  [one=(unit ,@da) two=(unit ,@da)]
  ^-  (unit ,@da)
  ?~  one  two
  ?~  two  one
  ?:((lth u.one u.two) one two)
::
```

XX document

###++meat

```
++  meat                                                ::  kite to .^ path
  |=  kit=kite
  ^-  path
  [(cat 3 'c' p.kit) (scot %p r.kit) s.kit (scot (dime q.kit)) t.kit]
::
```

XX document

###++mojo

```
++  mojo                                                ::  compiling load
  |=  [pax=path src=*]
  ^-  (each twig (list tank))
  ?.  ?=(@ src)
    [%| ~[[leaf/"musk: malformed: {<pax>}"]]]
  =+  ^=  mud
      %-  mule  |.
      ((full vest) [1 1] (trip src))
  ?:  ?=(| -.mud)  mud
  ?~  q.p.mud
    :~  %|
        leaf/"musk: syntax error: {<pax>}"
        leaf/"musk: line {<p.p.p.mud>}, column {<q.p.p.mud>}"
    ==
  [%& p.u.q.p.mud]
::
```

XX document

###++mole

```
++  mole                                                ::  new to old sky
  |=  ska=$+(* (unit (unit)))
  |=  a=*
  ^-  (unit)
  =+  b=(ska a)
  ?~  b  ~
  ?~  u.b  ~
  [~ u.u.b]
::
```

XX document

###++much

```
++  much                                                ::  constructing load
  |=  [pax=path src=*]
  ^-  gank
   =+  moj=(mojo pax src)
  ?:  ?=(| -.moj)  moj
  (mule |.((slap !>(+>.$) `twig`p.moj)))
::
```

XX document

###++musk

```
++  musk                                                ::  compiling apply
  |=  [pax=path src=* sam=vase]
  ^-  gank
  =+  mud=(much pax src)
  ?:  ?=(| -.mud)  mud
  (mule |.((slam p.mud sam)))
::
```

XX document

###++numb

```
++  numb                                                ::  ship display name
  |=  [him=@p our=@p now=@da]  ^-  @t
  =+  yow=(scot %p him)
  =+  pax=[(scot %p our) %name (scot %da now) yow ~]
  =+  woy=((hard ,@t) .^(%a pax))
  ?:  =(%$ woy)  yow
  (cat 3 yow (cat 3 ' ' woy))
::
```

XX document

###++saxo

```
++  saxo                                                ::  autocanon
  |=  who=ship
  ^-  (list ship)
  ?:  (lth who 256)  [who ~]
  [who $(who (sein who))]
::
```

XX document

###++sein

```
++  sein                                                ::  autoboss
  |=  who=ship  ^-  ship
  =+  mir=(clan who)
  ?-  mir
    %czar  who
    %king  (end 3 1 who)
    %duke  (end 4 1 who)
    %earl  (end 5 1 who)
    %pawn  `@p`0
  ==
::
```

XX document

###++tame

```
++  tame
  |=  hap=path
  ^-  (unit kite)
  ?.  ?=([@ @ @ @ *] hap)  ~
  =+  :*  hyr=(slay i.hap)
          fal=(slay i.t.hap)
          dyc=(slay i.t.t.hap)
          ved=(slay i.t.t.t.hap)
          ::  ved=(slay i.t.hap)
          ::  fal=(slay i.t.t.hap)
          ::  dyc=(slay i.t.t.t.hap)
          tyl=t.t.t.t.hap
      ==
  ?.  ?=([~ %$ %tas @] hyr)  ~
  ?.  ?=([~ %$ %p @] fal)  ~
  ?.  ?=([~ %$ %tas @] dyc)  ~
  ?.  ?=(^ ved)  ~
  =+  his=`@p`q.p.u.fal
  =+  [dis=(end 3 1 q.p.u.hyr) rem=(rsh 3 1 q.p.u.hyr)]
  ?.  ?&(?=(%c dis) ?=(?(%v %w %x %y %z) rem))  ~
  [~ rem (case p.u.ved) q.p.u.fal q.p.u.dyc tyl]
::
```

XX document

###++tome

```
++  tome                                                ::  parse path
  |=  pax=path
  ^-  (unit beam)
  ?.  ?=([* * * *] pax)  ~
  %+  biff  (slaw %p i.pax)
  |=  who=ship
  %+  biff  (slaw %tas i.t.pax)
  |=  dex=desk
  %+  biff  (slay i.t.t.pax)
  |=  cis=coin
  ?.  ?=([%$ case] cis)  ~
  `(unit beam)`[~ [who dex `case`p.cis] (flop t.t.t.pax)]
::
```

XX document

###++tope

```
++  tope                                                ::  beam to path
  |=  bem=beam
  ^-  path
  [(scot %p p.bem) q.bem (scot r.bem) (flop s.bem)]
```

XX document

##section 3bG, Arvo models

###++acru

```
++  acru                                                ::  asym cryptosuite
          $_  ^?  |%                                    ::  opaque object
```

XX document

###++as

```
          ++  as  ^?                                    ::  asym ops
            |%  ++  seal  |=([a=pass b=@ c=@] _@)       ::  encrypt to a
```

XX document

###++seal

```
++  seal                                                ::  auth conversation
          $:  whu=(unit ship)                           ::  client identity
              pul=purl                                  ::  destination url
              wit=?                                     ::  wait for partner
              foy=(unit ,[p=ship q=hole])               ::  partner to notify
              pus=(unit ,@ta)                           ::  password
          ==                                            ::
```

XX document

###++sign

```
                ++  sign  |=([a=@ b=@] _@)              ::  certify as us
```

XX document

###++sure

```
                ++  sure  |=([a=@ b=@] *(unit ,@))      ::  authenticate from us
```

XX document

###++tear

```
                ++  tear  |=  [a=pass b=@]              ::  accept from a 
                          *(unit ,[p=@ q=@])            ::
```

XX document

###++de

```
          ++  de  |+([a=@ b=@] *(unit ,@))              ::  symmetric de, soft
```

XX document

###++dy

```
          ++  dy  |+([a=@ b=@] _@)                      ::  symmetric de, hard
```

XX document

###++en

```
          ++  en  |+([a=@ b=@] _@)                      ::  symmetric en
```

XX document

###++ex

```
          ++  ex  ^?                                    ::  export
            |%  ++  fig  _@uvH                          ::  fingerprint
```

XX document

###++fig

``````

XX document

###++pac

```
                ++  pac  _@uvG                          ::  default passcode
```

XX document

###++pub

```
                ++  pub  *pass                          ::  public key
```

XX document

###++sec

```
                ++  sec  *ring                          ::  private key
```

XX document

###++nu

```
          ++  nu  ^?                                    ::  reconstructors
             |%  ++  pit  |=([a=@ b=@] ^?(..nu))        ::  from [width seed]
```

XX document

###++pit

``````

XX document

###++nol

```
                 ++  nol  |=(a=@ ^?(..nu))              ::  from naked ring
```

XX document

###++com

```
                 ++  com  |=(a=@ ^?(..nu))              ::  from naked pass
```

XX document

###++aeon

```
++  aeon  ,@ud                                          ::
```

XX document

###++agon

```
++  agon  (map ,[p=ship q=desk] ,[p=@ud q=@ud r=waks])  ::  mergepts
```

XX document

###++ankh

```
++  ankh                                                ::  fs node (new)
          $:  p=cash                                    ::  recursive hash
              q=(unit ,[p=cash q=*])                    ::  file
              r=(map ,@ta ankh)                         ::  folders
          ==                                            ::
```

XX document

###++ankz

```
++  ankz  ,[p=@ (map ,@ta ankz)]                        ::  trimmed ankh
```

XX document

###++apex

```
++  apex  ,[p=@uvI q=(map ,@ta ,@uvI) r=(map ,@ta ,~)]  ::  node report (old)
```

XX document

###++ares

```
++  ares  (unit ,[p=term q=(list tank)])                ::  possible error
```

XX document

###++ball

```
++  ball  ,@uw                                          ::  statement payload
```

XX document

###++bait

```
++  bait  ,[p=skin q=@ud r=dove]                        ::  fmt nrecvd spec
```

XX document

###++bath

```
++  bath                                                ::  convo per client
          $:  sop=shed                                  ::  not stalled
              raz=(map path race)                       ::  statements inbound
              ryl=(map path rill)                       ::  statements outbound
          ==                                            ::
```

XX document

###++beam

```
++  beam  ,[[p=ship q=desk r=case] s=path]              ::  global name
```

XX document

###++beak

```
++  beak  ,[p=ship q=desk r=case]                       ::  garnish with beak
```

XX document

###++bird

```
++  bird                                                ::  packet in travel
          $:  gom=soap                                  ::  message identity
              mup=@ud                                   ::  pktno in msg
              nux=@ud                                   ::  xmission count
              lys=@da                                   ::  last sent
              pac=rock                                  ::  packet data
          ==                                            ::
```

XX document

###++blob

```
++  blob  $%  [%delta p=lobe q=lobe r=udon]             ::  delta on q
              [%direct p=lobe q=* r=umph]               ::
              [%indirect p=lobe q=* r=udon s=lobe]      ::
          ==                                            ::
```

XX document

###++boat

```
++  boat  ,[(list slip) tart]                           ::  user stage
```

XX document

###++boon

```
++  boon                                                ::  fort output
          $%  [%beer p=ship q=@uvG]                     ::  gained ownership
              [%cake p=sock q=soap r=coop s=duct]       ::  e2e message result
              [%coke p=sock q=soap r=cape s=duct]       ::  message result
              [%mead p=lane q=rock]                     ::  accept packet
              [%milk p=sock q=soap r=*]                 ::  accept message
              [%mulk p=sock q=soap r=*]                 ::  e2e pass message
              [%ouzo p=lane q=rock]                     ::  transmit packet
              [%wine p=sock q=tape]                     ::  notify user
          ==                                            ::
```

XX document

###++bowl

```
++  bowl  ,[p=(list gift) q=(unit boat)]                ::  app product
```

XX document

###++bray

```
++  bray  ,[p=life q=(unit life) r=ship s=@da]          ::  our parent us now
```

XX document

###++brow

```
++  brow  ,[p=@da q=@tas]                               ::  browser version
```

XX document

###++buck

```
++  buck  ,[p=mace q=will]                              ::  all security data
```

XX document

###++cake

```
++  cake  ,[p=sock q=skin r=@]                          ::  top level packet
```

XX document

###++cape

```
++  cape                                                ::  end-to-end result
          $?  %good                                     ::  delivered
              %dead                                     ::  rejected
          ==                                            ::
```

XX document

###++cart

```
++  cart  ,[p=cash q=cash]                              ::  hash change
```

XX document

###++care

```
++  care  ?(%u %v %w %x %y %z)                          ::  clay submode
```

XX document

###++case

```
++  case                                                ::  ship desk case spur
          $%  [%da p=@da]                               ::  date
              [%tas p=@tas]                             ::  label
              [%ud p=@ud]                               ::  number
          ==                                            ::
```

XX document

###++cash

```
++  cash  ,@uvH                                         ::  ankh hash
```

XX document

###++chum

```
++  chum  ,@uvI                                         ::  hashed passcode
```

XX document

###++clot

```
++  clot                                                ::  symmetric record
          $:  yed=(unit ,[p=hand q=code])               ::  outbound
              heg=(map hand code)                       ::  proposed
              qim=(map hand code)                       ::  inbound
          ==                                            ::
```

XX document

###++coal

```
++  coal  ,*                                            ::  untyped vase
```

XX document

###++code

```
++  code  ,@uvI                                         ::  symmetric key
```

XX document

###++cone

```
++  cone                                                ::  reconfiguration
          $%  [& p=twig]                                ::  transform
              [| p=(list ,@tas)]                        ::  alter
          ==                                            ::
```

XX document

###++chum

```
++  chum  ,@uvI                                         ::  hashed passcode
```

XX document

###++claw

```
++  claw                                                ::  startup chain
          $:  joy=(unit coal)                           ::  local context
              ran=(unit coal)                           ::  arguments
              pux=(unit path)                           ::  execution path
              jiv=(unit coal)                           ::  app configuration
              kyq=(unit coal)                           ::  app customization
              gam=(unit coal)                           ::  app image
          ==                                            ::
```

XX document

###++clip

```
++  clip  (each ,@if ,@is)                              ::  client IP
```

XX document

###++coal

```
++  coal  ,*                                            ::  untyped vase
```

XX document

###++code

```
++  code  ,@uvI                                         ::  symmetric key
```

XX document

###++cone

```
++  cone                                                ::  reconfiguration
          $%  [& p=twig]                                ::  transform
              [| p=(list ,@tas)]                        ::  alter
          ==                                            ::
```

XX document

###++coop

```
++  coop  (unit ares)                                   ::  e2e ack
```

XX document

###++corn

```
++  corn                                                ::  flow by server
          $:  hen=duct                                  ::  admin channel
              nys=(map flap bait)                       ::  packets incoming
              olz=(map flap cape)                       ::  packets completed
              wab=(map ship bath)                       ::  relationship
          ==                                            ::
```

XX document

###++cred

```
++  cred                                                ::  credential
          $:  hut=hoot                                  ::  client host
              aut=(jug ,@tas ,@t)                       ::  client identities
              orx=oryx                                  ::  CSRF secret
              acl=(unit ,@t)                            ::  accept-language
              cip=(each ,@if ,@is)                      ::  client IP
              cum=(map ,@tas ,*)                        ::  custom dirt
          ==                                            ::
```

XX document

###++cuff

```
++  cuff                                                ::  permissions
          $:  p=(unit (set monk))                       ::  readers
              q=(set monk)                              ::  authors
          ==                                            ::
```

XX document

###++deed

```
++  deed  ,[p=@ q=step r=?]                             ::  sig, stage, fake?
```

XX document

###++dome

```
++  dome                                                ::  project state
          $:  ang=agon                                  ::  pedigree
              ank=ankh                                  ::  state
              let=@ud                                   ::  top id
              hit=(map ,@ud tako)                       ::  changes by id
              lab=(map ,@tas ,@ud)                      ::  labels
          ==                                            ::
```

XX document

###++dore

```
++  dore                                                ::  foreign contact
          $:  wod=road                                  ::  connection to
              wyl=will                                  ::  inferred mirror
              caq=clot                                  ::  symmetric key state
          ==                                            ::
```

XX document

###++dove

```
++  dove  ,[p=@ud q=(map ,@ud ,@)]                      ::  count hash 13-blocks
```

XX document

###++epic

```
++  epic                                                ::  FCGI parameters
          $:  qix=(map ,@t ,@t)                         ::  query
              ced=cred                                  ::  client credentials
              bem=beam                                  ::  original path
              but=path                                  ::  ending
              nyp=path                                  ::  request model
          ==                                            ::
```

XX document

###++flap

```
++  flap  ,@uvH                                         ::  network packet id
```

XX document

###++flow

```
++  flow                                                ::  packet connection
          $:  rtt=@dr                                   ::  decaying avg rtt
              wid=@ud                                   ::  logical wdow msgs
          ==                                            ::
```

XX document

###++fort

```
++  fort                                                ::  formal state
          $:  %0                                        ::  version
              gad=duct                                  ::  client interface
              hop=@da                                   ::  network boot date
              ton=town                                  ::  security
              zac=(map ship corn)                       ::  flows by server
          ==                                            ::
```

XX document

###++frog

```
++  frog  ,[p=@da q=nori]                               ::  time and change
```

XX document

###++gank

```
++  gank  (each vase (list tank))                       ::  abstract result
```

XX document

###++gift

```
++  gift                                                ::  one-way effect
          $%  [%$ p=vase]                               ::  trivial output
              [%cc p=(unit case)]                       ::  change case
              [%ck p=@tas]                              ::  change desk
              [%cs p=path]                              ::  change spur
              [%de p=@ud q=tank]                        ::  debug/level
              [%ex p=(unit vase) q=lath]                ::  exec/patch
            ::[%fd p=vase]                              ::  fundamental down
            ::[%fo p=vase]                              ::  fundamental forward
            ::[%fu p=vase]                              ::  fundamental up
              [%ha p=tank]                              ::  single error
              [%ho p=(list tank)]                       ::  multiple error
              [%la p=tank]                              ::  single statement
              [%lo p=(list tank)]                       ::  multiple statement
              [%mu p=type q=(list)]                     ::  batch emit
              [%mx p=(list gift)]                       ::  batch gift
              [%ok p=@ta q=nori]                        ::  save changes
              [%og p=@ta q=mizu]                        ::  save direct
              [%sc p=(unit skit)]                       ::  stack library
              [%sp p=(list lark)]                       ::  spawn task(s)
              [%sq p=ship q=@tas r=path s=*]            ::  send request
              [%sr p=ship q=path r=*]                   ::  send response
              [%te p=(list ,@t)]                        ::  dump lines
              [%th p=@ud q=love]                        ::  http response
              [%tq p=path q=hiss]                       ::  http request
              [%va p=@tas q=(unit vase)]                ::  set/clear variable
              [%xx p=curd]                              ::  return card
              [%xy p=path q=curd]                       ::  push card
              [%xz p=[p=ship q=term] q=ship r=mark s=zang]
              [%zz p=path q=path r=curd]                ::
          ==                                            ::
```

XX document

###++zang

```
++  zang                                                ::  XX evil hack
          $%  [%backlog p=path q=?(%da %dr %ud) r=@]    ::
              [%hola p=path]                            ::
              $:  %mess  p=path                         ::
                $=  q                                   ::
              $%  [%do p=@t]                            ::  act
                  [%exp p=@t q=tank]                    ::  code
                  [%say p=@t]                           ::  speak
              ==  ==                                    ::
              [%tint p=ship]                            ::
          ==                                            ::
```

XX document

###++gilt

```
++  gilt  ,[@tas *]                                     ::  presumed gift
```

XX document

###++gens

```
++  gens  ,[p=lang q=gcos]                              ::  general identity
```

XX document

###++germ

```
++  germ  ?(%init %fine %that %this %mate %meld)        ::  merge style
```

XX document

###++gcos

```
++  gcos                                                ::  id description
          $%  [%czar ~]                                 ::  8-bit ship
              [%duke p=what]                            ::  32-bit ship
              [%earl p=@t]                              ::  64-bit ship
              [%king p=@t]                              ::  16-bit ship
              [%pawn p=(unit ,@t)]                      ::  128-bit ship
          ==                                            ::
```

XX document

###++goad

```
++  goad                                                ::  common note
          $%  [%eg p=riot]                              ::  simple result
              [%gr p=mark q=*]                          ::  gall rush/rust
              [%hp p=httr]                              ::  http response
              ::  [%ht p=@ud q=scab r=cred s=moth]          ::  http request
              [%it p=~]                                 ::  interrupt event
              [%lq p=ship q=path r=*]                   ::  client request
              [%ly p=newt q=tape]                       ::  lifecycle event
              [%ow p=cape]                              ::  one-way reaction
              [%rt p=(unit)]                            ::  roundtrip response
              [%up p=@t]                                ::  prompt response
              [%wa ~]                                   ::  alarm
          ==                                            ::
```

XX document

###++goal

```
++  goal                                                ::  app request
          $%  [%$ p=type]                               ::  open for input
              [%do p=vase q=vase]                       ::  call gate sample
              [%eg p=kite]                              ::  single request
              [%es p=ship q=desk r=rave]                ::  subscription
              [%gr ~]                                   ::  gall response
              [%ht p=(list rout)]                       ::  http server
              [%hp ~]                                   ::  http response
              [%lq p=@tas]                              ::  listen for service
              [%ow ~]                                   ::  one-way reaction
              [%rt ~]                                   ::  roundtrip response
              [%up p=prod]                              ::  user prompt
              [%wa p=@da]                               ::  alarm
          ==                                            ::
```

XX document

###++govt

```
++  govt  path                                          ::  country/postcode
```

XX document

###++hand

```
++  hand  ,@uvH                                         ::  hash of code
```

XX document

###++hart

```
++  hart  ,[p=? q=(unit ,@ud) r=host]                   ::  http sec/port/host
```

XX document

###++hate

```
++  hate  ,[p=purl q=@p r=moth]                         ::  semi-cooked request
```

XX document

###++heir

```
++  heir  ,[p=@ud q=mess r=(unit love)]                 ::  status/headers/data
```

XX document

###++hiss

```
++  hiss  ,[p=purl q=moth]                              ::  outbound request
```

XX document

###++hist

```
++  hist  ,[p=@ud q=(list ,@t)]                         ::  depth texts
```

XX document

###++hole

```
++  hole  ,@t                                           ::  session identity
```

XX document

###++hoot

```
++  hoot  ,[p=? q=(unit ,@ud) r=host]                   ::  secure/port/host
```

XX document

###++hort

```
++  hort  ,[p=(unit ,@ud) q=host]                       ::  http port/host
```

XX document

###++host

```
++  host  $%([& p=(list ,@t)] [| p=@if])                ::  http host
```

XX document

###++httq

```
++  httq                                                ::  raw http request
          $:  p=meth                                    ::  method
              q=@t                                      ::  unparsed url
              r=(list ,[p=@t q=@t])                     ::  headers
              s=(unit octs)                             ::  body
          ==                                            ::
```

XX document

###++httr

```
++  httr  ,[p=@ud q=mess r=(unit octs)]                 ::  raw http response
```

XX document

###++httx

```
++  httx                                                ::  encapsulated http
          $:  p=?                                       ::  https?
              q=clip                                    ::  source IP
              r=httq                                    ::
          ==                                            ::
```

XX document

###++kite

```
++  kite  ,[p=care q=case r=ship s=desk t=spur]         ::  parsed global name
```

XX document

###++json

```
++  json                                                ::  normal json value
          $|  ~                                         ::  null
          $%  [%a p=(list json)]                        ::  array
              [%b p=?]                                  ::  boolean
              [%o p=(map ,@t json)]                     ::  object
              [%n p=@ta]                                ::  number
              [%s p=@ta]                                ::  string
          ==                                            ::
```

XX document

###++jsot

```
++  jsot                                                ::  strict json top
          $%  [%a p=(list json)]                        ::  array
              [%o p=(map ,@t json)]                     ::  object
          ==                                            ::
```

XX document

###++lamb

```
++  lamb                                                ::  short path
          $%  [& p=@tas]                                ::  auto
              [| p=twig]                                ::  manual
          ==                                            ::
```

XX document

###++lane

```
++  lane                                                ::  packet route
          $%  [%if p=@da q=@ud r=@if]                   ::  IP4/public UDP/addr
              [%is p=@ud q=(unit lane) r=@is]           ::  IPv6 w/alternates
              [%ix p=@da q=@ud r=@if]                   ::  IPv4 provisional
          ==                                            ::
```

XX document

###++lang

```
++  lang  ,@ta                                          ::  IETF lang as code
```

XX document

###++lark

```
++  lark  ,[p=(unit ,@tas) q=lawn]                      ::  parsed command
```

XX document

###++lass

```
++  lass  ?(%0 %1 %2)                                   ::  power increment
```

XX document

###++lath

```
++  lath  $%                                            ::  pipeline stage
              [%0 p=lass q=lamb r=(list cone) s=twig]   ::  command
              [%1 p=twig]                               ::  generator
              [%2 p=twig]                               ::  filter
          ==                                            ::
```

XX document

###++lawn

```
++  lawn  (list lath)                                   ::
```

XX document

###++lice

```
++  lice  ,[p=ship q=buck]                              ::  full license
```

XX document

###++life

```
++  life  ,@ud                                          ::  regime number
```

XX document

###++lint

```
++  lint  (list rock)                                   ::  fragment array
```

XX document

###++lobe

```
++  lobe  ,@                                            ::  blob ref
```

XX document

###++love

```
++  love  $%                                            ::  http response
              [%ham p=manx]                             ::  html node
              [%mid p=mite q=octs]                      ::  mime-typed data
              [%raw p=httr]                             ::  raw http response
              [%wan p=wain]                             ::  text lines
              [%zap p=@ud q=(list tank)]                ::  status/error
          ==                                            ::
```

XX document

###++luge

```
++  luge  ,[p=mark q=*]                                 ::  fully typed content
```

XX document

###++maki

```
++  maki  ,[p=@ta q=@ta r=@ta s=path]                   ::
```

XX document

###++mace

```
++  mace  (list ,[p=life q=ring])                       ::  private secrets
```

XX document

###++marv

```
++  marv  ?(%da %tas %ud)                               ::  release form
```

XX document

###++math

```
++  math  (map ,@t (list ,@t))                          ::  semiparsed headers
```

XX document

###++meal

```
++  meal                                                ::  payload
          $%  [%back p=cape q=flap r=@dr]               ::  acknowledgment
              [%buck p=coop q=flap r=@dr]               ::  e2e ack
              [%bond p=life q=path r=@ud s=*]           ::  message
              [%bund p=life q=path r=@ud s=*]           ::  e2e message
              [%carp p=@ q=@ud r=@ud s=flap t=@]        ::  skin/inx/cnt/hash
              [%fore p=ship q=(unit lane) r=@]          ::  forwarded packet
          ==                                            ::
```

XX document

###++mess

```
++  mess  (list ,[p=@t q=@t])                           ::  raw http headers
```

XX document

###++meta

```
++  meta                                                ::  path metadata
          $%  [& q=@uvI]                                ::  hash
              [| q=(list ,@ta)]                         ::  dir
          ==                                            ::
```

XX document

###++meth

```
++  meth                                                ::  http methods
          $?  %conn                                     ::  CONNECT
              %delt                                     ::  DELETE
              %get                                      ::  GET
              %head                                     ::  HEAD
              %opts                                     ::  OPTIONS
              %post                                     ::  POST
              %put                                      ::  PUT
              %trac                                     ::  TRACE
          ==                                            ::
```

XX document

###++mite

```
++  mite  (list ,@ta)                                   ::  mime type
```

XX document

###++miso

```
++  miso                                                ::  ankh delta
          $%  [%del p=*]                                ::  delete
              [%ins p=*]                                ::  insert
              [%mut p=udon]                             ::  mutate
          ==                                            ::
```

XX document

###++mizu

```
++  mizu  ,[p=@u q=(map ,@ud tako) r=rang]              ::  new state
```

XX document

###++moar

```
++  moar  ,[p=@ud q=@ud]                                ::  normal change range
```

XX document

###++moat

```
++  moat  ,[p=case q=case r=path]                       ::  change range
```

XX document

###++mood

```
++  mood  ,[p=care q=case r=path]                       ::  request in desk
```

XX document

###++moth

```
++  moth  ,[p=meth q=math r=(unit octs)]                ::  http operation
```

XX document

###++name

```
++  name  ,[p=@t q=(unit ,@t) r=(unit ,@t) s=@t]        ::  first mid/nick last
```

XX document

###++newt

```
++  newt  ?(%boot %kick %mess %slay %wake)              ::  lifecycle events
```

XX document

###++nose

```
++  nose                                                ::  response, kernel
          $?  [%$ p=(unit ,[p=tutu q=(list)])]          ::  standard input
              goad                                      ::
          ==                                            ::
```

XX document

###++note

```
++  note                                                ::  response, user
          $?  [%$ p=(unit ,[p=type q=(list)])]          ::  standard input
              [%do p=vase]                              ::  execution result
              goad                                      ::
          ==                                            ::
```

XX document

###++nori

```
++  nori                                                ::  repository action
          $%  [& q=soba]                                ::  delta
              [| p=@tas]                                ::  label
          ==                                            ::
```

XX document

###++octs

```
++  octs  ,[p=@ud q=@]                                  ::  octet-stream
```

XX document

###++oryx

```
++  oryx  ,@t                                           ::  CSRF secret
```

XX document

###++pact

```
++  pact  path                                          ::  routed path
```

XX document

###++pail

```
++  pail  ?(%none %warm %cold)                          ::  connection status
```

XX document

###++plan

```
++  plan  (trel view (pair ,@da (unit ,@dr)) path)      ::  subscription
```

XX document

###++plea

```
++  plea  ,[p=@ud q=[p=? q=@t]]                         ::  live prompt
```

XX document

###++pork

```
++  pork  ,[p=(unit ,@ta) q=(list ,@t)]                 ::  fully parsed url
```

XX document

###++pred

```
++  pred  ,[p=@ta q=@tas r=@ta ~]                       ::  proto-path
```

XX document

###++prod

```
++  prod  ,[p=prom q=tape r=tape]                       ::  prompt
```

XX document

###++prom

```
++  prom  ?(%text %pass %none)                          ::  format type
```

XX document

###++purl

```
++  purl  ,[p=hart q=pork r=quay]                       ::  parsed url
```

XX document

###++putt

```
++  putt                                                ::  outgoing message
          $:  ski=snow                                  ::  sequence acked/sent
              wyv=(list rock)                           ::  packet list XX gear
          ==                                            ::
```

XX document

###++pyre

```
++  pyre                                                ::  cascade stash
          $:  p=(map ,[p=path q=path r=coal] coal)      ::  by path
              q=(map ,[p=path q=@uvI r=coal] coal)      ::  by source hash
              r=(map ,[p=* q=coal] coal)                ::  by (soft) twig
          ==                                            ::
```

XX document

###++quay

```
++  quay  (list ,[p=@t q=@t])                           ::  parsed url query
```

XX document

###++quri

```
++  quri                                                ::  request-uri
          $%  [& p=purl]                                ::  absolute
              [| p=pork q=quay]                         ::  relative
          ==                                            ::
```

XX document

###++race

```
++  race                                                ::  inbound stream
          $:  did=@ud                                   ::  filled sequence
              dod=?                                     ::  not processing
              bum=(map ,@ud ares)                       ::  nacks
              mis=(map ,@ud ,[p=cape q=lane r=flap s=(unit)]) ::  misordered
          ==                                            ::
```

XX document

###++rank

```
++  rank  ?(%czar %king %duke %earl %pawn)              ::  ship width class
```

XX document

###++rang

```
++  rang  $:  hut=(map tako yaki)                       ::
              lat=(map lobe blob)                       ::
          ==                                            ::
```

XX document

###++rant

```
++  rant                                                ::  namespace binding
          $:  p=[p=care q=case r=@tas]                  ::  clade release book
              q=path                                    ::  spur
              r=*                                       ::  data
          ==                                            ::
```

XX document

###++rave

```
++  rave                                                ::  general request
          $%  [& p=mood]                                ::  single request
              [| p=moat]                                ::  change range
          ==                                            ::
```

XX document

###++rill

```
++  rill                                                ::  outbound stream
          $:  sed=@ud                                   ::  sent
              san=(map ,@ud duct)                       ::  outstanding
          ==                                            ::
```

XX document

###++riot

```
++  riot  (unit rant)                                   ::  response/complete
```

XX document

###++road

```
++  road                                                ::  secured oneway route
          $:  exp=@da                                   ::  expiration date
              lun=(unit lane)                           ::  route to friend
              lew=will                                  ::  will of friend
          ==                                            ::
```

XX document

###++rock

```
++  rock  ,@uvO                                         ::  packet
```

XX document

###++rout

```
++  rout  ,[p=(list host) q=path r=oryx s=path]         ::  http route (new)
```

XX document

###++rump

```
++  rump  ,[p=care q=case r=@tas s=path]                ::  relative path
```

XX document

###++saba

```
++  saba  ,[p=ship q=@tas r=moar s=dome]                ::  patch/merge
```

XX document

###++sack

```
++  sack  ,[p=ship q=ship]                              ::  incoming [our his]
```

XX document

###++sufi

```
++  sufi                                                ::  domestic host
          $:  hoy=(list ship)                           ::  hierarchy
              val=wund                                  ::  private keys
              law=will                                  ::  server will
              seh=(map hand ,[p=ship q=@da])            ::  key cache
              hoc=(map ship dore)                       ::  neighborhood
          ==                                            ::
```

XX document

###++salt

```
++  salt  ,@uv                                          ::  entropy
```

XX document

###++seal

```
++  seal                                                ::  auth conversation
          $:  whu=(unit ship)                           ::  client identity
              pul=purl                                  ::  destination url
              wit=?                                     ::  wait for partner
              foy=(unit ,[p=ship q=hole])               ::  partner to notify
              pus=(unit ,@ta)                           ::  password
          ==                                            ::
```

XX document

###++sect

```
++  sect  ?(%black %blue %red %orange %white)           ::  banner
```

XX document

###++shed

```
++  shed                                                ::  packet flow
          $:  $:  rtt=@dr                               ::  smoothed rtt
                  rto=@dr                               ::  retransmit timeout
                  rtn=(unit ,@da)                       ::  next timeout
                  rue=(unit ,@da)                       ::  last heard from
              ==                                        ::
              $:  nus=@ud                               ::  number sent
                  nif=@ud                               ::  number live
                  nep=@ud                               ::  next expected
                  caw=@ud                               ::  logical window
                  cag=@ud                               ::  congest thresh
              ==                                        ::
              $:  diq=(map flap ,@ud)                   ::  packets sent
                  pyz=(map soup ,@ud)                   ::  message/unacked
                  puq=(qeu ,[p=@ud q=soul])             ::  packet queue
              ==                                        ::
          ==                                            ::
```

XX document

###++skit

```
++  skit  ,[p=(unit ,@ta) q=(list ,@ta) r=(list ,@ta)]  ::  tracking path
```

XX document

###++skin

```
++  skin  ?(%none %open %fast %full)                    ::  encoding stem
```

XX document

###++slip

```
++  slip  ,[p=path q=goal]                              ::  traceable request
```

XX document

###++snow

```
++  snow  ,[p=@ud q=@ud r=(set ,@ud)]                   ::  window exceptions
```

XX document

###++soap

```
++  soap  ,[p=[p=life q=life] q=path r=@ud]             ::  statement id
```

XX document

###++soup

```
++  soup  ,[p=path q=@ud]                               ::  new statement id
```

XX document

###++soul

```
++  soul                                                ::  packet in travel
          $:  gom=soup                                  ::  message identity
              nux=@ud                                   ::  xmission count
              liv=?                                     ::  deemed live
              lys=@da                                   ::  last sent
              pac=rock                                  ::  packet data
          ==                                            ::
```

XX document

###++soba

```
++  soba  ,[p=cart q=(list ,[p=path q=miso])]           ::  delta
```

XX document

###++sock

```
++  sock  ,[p=ship q=ship]                              ::  outgoing [from to]
```

XX document

###++spur

```
++  spur  path                                          ::  ship desk case spur
```

XX document

###++step

```
++  step  ,[p=bray q=gens r=pass]                       ::  identity stage
```

XX document

###++tako

```
++  tako  ,@                                            ::  yaki ref
```

XX document

###++tart

```
++  tart  $+([@da path note] bowl)                      ::  process core
```

XX document

###++taxi

```
++  taxi  ,[p=lane q=rock]                              ::  routed packet
```

XX document

###++tick

```
++  tick  ,@ud                                          ::  process id
```

XX document

###++toro

```
++  toro  ,[p=@ta q=nori]                               ::  general change
```

XX document

###++town

```
++  town                                                ::  all security state
          $:  lit=@ud                                   ::  imperial modulus
              any=@                                     ::  entropy
              urb=(map ship sufi)                       ::  all keys and routes
              fak=?                                     ::
          ==                                            ::
```

XX document

###++tube

```
++  tube  ,[p=@ta q=@ta r=@ta s=path]                   ::  canonical path
```

XX document

###++tutu

```
++  tutu  ,*                                            ::  presumed type
```

XX document

###++yaki

```
++  yaki  ,[p=(list tako) q=(map path lobe) r=tako t=@da] ::  commit
```

XX document

###++view

```
++  view  ?(%u %v %w %x %y %z)                          ::  view mode
```

XX document

###++waks

```
++  waks  (map path woof)                               ::  list file states
```

XX document

###++what

```
++  what                                                ::  logical identity
          $%  [%anon ~]                                 ::  anonymous
              [%lady p=whom]                            ::  female person ()
              [%lord p=whom]                            ::  male person []
              [%punk p=sect q=@t]                       ::  opaque handle ""
          ==                                            ::
```

XX document

###++whom

```
++  whom  ,[p=@ud q=govt r=sect s=name]                 ::  year/govt/id
```

XX document

###++woof

```
++  woof  $|  %know                                     ::  udon transform
              [%chan (list $|(@ud [p=@ud q=@ud]))]      ::
```

XX document

###++wund

```
++  wund  (list ,[p=life q=ring r=acru])                ::  mace in action
```

XX document

###++will

```
++  will  (list deed)                                   ::  certificate
```

XX document

###++worm

```
++  worm  ,*                                            ::  vase of tart
```

XX document

###++zuse

```
++  zuse  %314                                          ::  hoon/zuse kelvin
--
```

XX document

